<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>SmartRosary Installer</title>
    <meta name="description" content="Easily install SmartRosary firmware on the web." />
    <meta name="viewport" content="width=device-width" />
    <meta name="color-scheme" content="dark light" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
      body { font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, sans-serif; padding: 0; margin: 0; line-height: 1.4; }
      .content { max-width: 600px; margin: 0 auto; padding: 12px; }
      h1 { margin-top: 0.6em; text-align: center; }
      h2 { margin-top: 1.0em; text-align: center; }
      a { color: #03a9f4; }
      .uploadBox { border-top: 1px solid #ccc; padding-bottom: 20px; }
      .uploadBtn { cursor: pointer; font-size: 14px; font-weight: 500; padding: 10px 24px; color: #fff; background-color: #03a9f4; border: none; border-radius: 9999px; }
      .footer{text-align: center;}
      .controls-container {display: flex; justify-content: center; margin-bottom: 1rem;}
      .controls-table {border-collapse: collapse;}
      .controls-table td {border: none; padding: 0.3rem 0.5rem; vertical-align: middle;}
      label { display: inline-block; width: 120px; }
      .langRow { text-align:center; padding: 10px 0 0; }
      .langRow select { font-size: 14px; padding: 6px 10px; }

      /* Movable progress container */
      #ProgressContainer { display: none; padding: 12px 12px 16px; margin-top: 10px; margin-bottom: 8px; border-radius: 10px; background: #f1f5f9; border: 1px solid #cbd5e1; }
      #progressTitle { font-size: 14px; font-weight: 600; margin-bottom: 6px; text-align:center; }
      #progressRow { display:flex; flex-direction:column; align-items:center; gap:6px; }
      #progressBar { width:100%; height: 30px; }
      #progressText { font-weight: 600; }

      /* Horizontal line under progress */
      .sep { display:none; border:0; border-top:1px solid #cbd5e1; margin: 10px 0 16px; }

      @media (prefers-color-scheme: dark) {
        #ProgressContainer { background: #0f172a; border-color: #334155; }
        #progressTitle { color: #cbd5e1; }
        .sep { border-top-color: #334155; }
      }
    </style>
    <script type="module" src="https://unpkg.com/esp-web-tools@10.1.0/dist/web/install-button.js"></script>
  </head>
  <body>
    <div class="content">

      <!-- Language selector (UI only) -->
      <div class="langRow">
        <label for="uiLangSelect">üåê <span id="uiLangLabel">Language</span>:</label>
        <select id="uiLangSelect">
          <option value="pl">Polski</option>
          <option value="de">Deutsch</option>
          <option value="en" selected>English</option>
        </select>
      </div>

      <h1 id="title">SmartRosary Web Installer</h1>

      <!-- USB -->
      <div class="uploadBox" id="usbBox">
        <h2 id="usbTitle">Upload firmware v0.93 via USB</h2>
        <div class="controls-container">
          <table class="controls-table">
            <tr>
              <td><label for="language" id="fwLangLabel">Language (firmware data):</label></td>
              <td>
                <select id="language">
                  <option value="pl">Polski</option>
                  <option value="en">English</option>
                  <option value="de">Deutsch</option>
                </select>
              </td>
            </tr>
            <tr>
              <td><label for="intentions" id="intentionsLabel">Intentions:</label></td>
              <td>
                <select id="intentions">
                  <option value="none">None</option>
                  <option value="rosary">≈ªywy R√≥≈ºaniec 2025 (PMK D√ºsseldorf)</option>
                </select>
              </td>
            </tr>
          </table>
        </div>
        <p align="center"><esp-web-install-button></esp-web-install-button></p>
        <div class="footer">USB Installer powered by <a href="https://esphome.github.io/esp-web-tools/">ESP Web Tools</a>.</div>
      </div>

      <!-- OTA: Firmware -->
      <div class="uploadBox" id="otaFwBox">
        <h2 id="otaTitle">Upload firmware v0.93 via OTA</h2>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadFirmwareBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- OTA: Language -->
      <div class="uploadBox" id="otaLangBox">
        <h2 id="langTitle">Upload language via OTA</h2>
        <div style="text-align: center; margin-top: 1em;">
          <select id="languageFileSelect">
            <option value="lang/nvs-lang-pl.bin">Polski</option>
            <option value="lang/nvs-lang-en.bin">English</option>
            <option value="lang/nvs-lang-de.bin">Deutsch</option>
          </select>
        </div>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadLanguageBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- OTA: Intentions -->
      <div class="uploadBox" id="otaIntsBox">
        <h2 id="intentsTitle">Upload intentions via OTA</h2>
        <div style="text-align: center; margin-top: 1em;">
          <select id="intentionsFileSelect">
            <option value="intentions/nvs-intentions-pmkdus-2025.bin">≈ªywy R√≥≈ºaniec 2025 (PMK D√ºsseldorf)</option>
          </select>
        </div>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadIntentionsBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- Movable Progress -->
      <div id="ProgressContainer">
        <div id="progressTitle">Uploading‚Ä¶</div>
        <div id="progressRow">
          <progress id="progressBar" value="0" max="0"></progress>
          <div>
            <span id="progressText">0%</span>
            <span style="margin-left: 5px;" id="progressChunks">(0/0 Bytes)</span>
          </div>
        </div>
      </div>
      <hr id="ProgressHR" class="sep" />

      <div id="log" style="display:none;"></div>
    </div>

    <!-- Wake lock helpers -->
    <script src="https://lib.arvancloud.ir/nosleep/0.9.0/NoSleep.min.js"></script>
    <script>
      const FW_VERSION = "v0.93";

      // i18n
      const i18n = {
        pl: { langLabel:"Jƒôzyk", title:"SmartRosary Instalator", usbTitle:`Wgraj firmware ${FW_VERSION} przez USB`, otaTitle:`Wgraj firmware ${FW_VERSION} przez OTA`, langTitle:"Wgraj jƒôzyk przez OTA", intentsTitle:"Wgraj intencje przez OTA", connectUpload:"Po≈ÇƒÖcz i wgraj", fwLangLabel:"Jƒôzyk:", intentionsLabel:"Intencje:" },
        de: { langLabel:"Sprache", title:"SmartRosary Installer", usbTitle:`Firmware ${FW_VERSION} per USB hochladen`, otaTitle:`Firmware ${FW_VERSION} per OTA hochladen`, langTitle:"Sprache per OTA hochladen", intentsTitle:"Intentionen per OTA hochladen", connectUpload:"Verbinden & Hochladen", fwLangLabel:"Sprache:", intentionsLabel:"Intentionen:" },
        en: { langLabel:"Language", title:"SmartRosary Installer", usbTitle:`Upload firmware ${FW_VERSION} via USB`, otaTitle:`Upload firmware ${FW_VERSION} via OTA`, langTitle:"Upload language via OTA", intentsTitle:"Upload intentions via OTA", connectUpload:"Connect & Upload", fwLangLabel:"Language:", intentionsLabel:"Intentions:" }
      };

      function setLanguage(lang) {
        const t = i18n[lang] || i18n.en;
        document.getElementById("uiLangLabel").textContent = t.langLabel;
        document.getElementById("title").textContent       = t.title;
        document.getElementById("usbTitle").textContent    = t.usbTitle;
        document.getElementById("otaTitle").textContent    = t.otaTitle;
        document.getElementById("langTitle").textContent   = t.langTitle;
        document.getElementById("intentsTitle").textContent= t.intentsTitle;
        document.getElementById("fwLangLabel").textContent = t.fwLangLabel;
        document.getElementById("intentionsLabel").textContent = t.intentionsLabel;
        document.querySelectorAll(".uploadBtn").forEach(btn => btn.textContent = t.connectUpload);
      }
      document.getElementById("uiLangSelect").addEventListener("change", e => setLanguage(e.target.value));
      setLanguage(document.getElementById("uiLangSelect").value);

      // Wake lock
      let wakeLock = null;
      async function enableWakeLock() {
        try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); }
        catch (err) { console.warn('WakeLock error:', err); }
      }
      const noSleep = new NoSleep();
      function preventStandby(){ enableWakeLock(); try{ noSleep.enable(); }catch{} }

      // Progress helpers (fixed initialization)
      const progressContainer = document.getElementById('ProgressContainer');
      const progressHR        = document.getElementById('ProgressHR');
      const progressTitleEl   = document.getElementById('progressTitle');
      const progressBar       = document.getElementById('progressBar');
      const progressTextEl    = document.getElementById('progressText');
      const progressChunksEl  = document.getElementById('progressChunks');

      function showProgressContainer(anchorBox, title) {
        progressTitleEl.textContent = title || 'Uploading‚Ä¶';
        progressBar.value = 0; progressBar.max = 0;
        progressTextEl.textContent = '0%';
        progressChunksEl.textContent = '(0/0 Bytes)';
        progressContainer.style.display = 'block';
        progressHR.style.display = 'block';
        anchorBox.insertAdjacentElement('afterend', progressContainer);
        progressContainer.insertAdjacentElement('afterend', progressHR);
        window.scrollTo({ top: progressContainer.offsetTop - 16, behavior: 'smooth' });
      }
      function hideProgressContainer(){ progressContainer.style.display='none'; progressHR.style.display='none'; }
      function updateProgress(sent,total){ progressBar.max=total; progressBar.value=sent; progressTextEl.textContent=Math.round((sent/total)*100)+'%'; progressChunksEl.textContent=`(${sent}/${total} Bytes)`; }
    </script>

    <!-- OTA uploader (firmware / lang / intentions) -->
    <script>
      // UUIDs ‚Äî MUST match firmware (lowercase)
      const SERVICE_UUID       = '12345678-1234-5678-1234-56789abcdef0';
      const FIRMWARE_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef1';
      const INTENTS_CHAR_UUID  = '12345678-1234-5678-1234-56789abcde10';
      const LANG_CHAR_UUID     = '12345678-1234-5678-1234-56789abcde20';
      const STATUS_CHAR_UUID   = '12345678-1234-5678-1234-56789abcdef2';
      const INFO_CTRL_UUID     = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e10ff';  // <‚Äî ADD THIS
      

      let device, writeChar, statusChar;
      let ready = true;

      document.getElementById('uploadFirmwareBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startFirmwareOTA(ev.currentTarget); }
        catch (e) { alert(e.message || 'Firmware OTA failed.'); }
      });
      document.getElementById('uploadIntentionsBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startIntentionsOTA(ev.currentTarget); }
        catch (e) { alert(e.message || 'Intentions OTA failed.'); }
      });
      document.getElementById('uploadLanguageBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startLanguageOTA(ev.currentTarget); }
        catch (e) { alert(e.message || 'Language OTA failed.'); }
      });

      async function helloAndAwaitConsent(svc) {
        // Get control + status characteristics
        const ctrlChar  = await svc.getCharacteristic(INFO_CTRL_UUID);
        const statChar  = await svc.getCharacteristic(STATUS_CHAR_UUID);

        // Start notifications (we‚Äôll also keep this statusChar as the global one)
        await statChar.startNotifications();

        // Wait for 0xA1 (allow) or 0xA0 (deny)
        const allowed = await new Promise(async (resolve) => {
          const onStatus = (ev) => {
            const v = new Uint8Array(ev.target.value.buffer)[0];
            if (v === 0xA1 || v === 0xA0) {
              statChar.removeEventListener('characteristicvaluechanged', onStatus);
              resolve(v === 0xA1);
            }
          };
          statChar.addEventListener('characteristicvaluechanged', onStatus);

          // Send HELLO_WEB (0x41) to pop consent on the device
          await ctrlChar.writeValue(Uint8Array.of(0x41));

          // Hard timeout to avoid hanging forever
          setTimeout(() => {
            try { statChar.removeEventListener('characteristicvaluechanged', onStatus); } catch {}
            resolve(false);
          }, 25000);
        });

        return allowed;
      }

      async function waitReady(){ while(!ready) await new Promise(r=>setTimeout(r,50)); ready=false; }

      // More robust BLE discovery: prefer service filter, fallback to acceptAllDevices
      async function connectBLE(svcUuid, charUuid){
        // 1) Pick device (prefer service filter; fallback acceptAllDevices)
        try {
          device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [svcUuid] }],
            optionalServices: [svcUuid, SERVICE_UUID] // ensure our main service is always discoverable
          });
        } catch (e) {
          device = await navigator.bluetooth.requestDevice({
            acceptAllDevices: true,
            optionalServices: [svcUuid, SERVICE_UUID]
          });
          if (!device.name || !device.name.toLowerCase().startsWith('rosary')) {
            throw new Error('Picked device is not a rosary (name check failed).');
          }
        }

        // 2) Connect
        const gatt = await device.gatt.connect();

        // 3) Always get the main OTA service (it contains STATUS + INFO_CTRL)
        const svc = await gatt.getPrimaryService(SERVICE_UUID);

        // 4) Ask for consent (HELLO_WEB -> LVGL ‚ÄúAllow Web‚Äù modal on device)
        const consent = await helloAndAwaitConsent(svc);
        if (!consent) {
          try {
            // optional: tell device we‚Äôre backing out
            const ctrl = await svc.getCharacteristic(INFO_CTRL_UUID);
            await ctrl.writeValue(Uint8Array.of(0x42)); // CANCEL_WEB
          } catch {}
          throw new Error('Device denied consent or timed out. Please tap "Allow" on the device and try again.');
        }

        // 5) Now it‚Äôs safe to use your target write characteristic
        //    (firmware / language / intentions are separate chars under the same service)
        writeChar  = await svc.getCharacteristic(charUuid);

        // 6) Keep a global statusChar for ‚Äúready/ACK‚Äù pacing (also used above in consent)
        try {
          statusChar = await svc.getCharacteristic(STATUS_CHAR_UUID);
          statusChar.addEventListener('characteristicvaluechanged', () => { ready = true; });
          // It‚Äôs already started in helloAndAwaitConsent, but starting again is harmless
          await statusChar.startNotifications();
        } catch {
          // optional
        }
      }

      function setProgress(sent,total){
        updateProgress(sent,total);
      }

      async function startFirmwareOTA(btn){
        const resp = await fetch('firmware/firmware.bin'); if(!resp.ok){ alert('firmware.bin not found'); return; }
        const data = new Uint8Array(await resp.arrayBuffer());

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,FIRMWARE_CHAR_UUID);
        const box = btn.closest('.uploadBox') || document.getElementById('otaFwBox');
        showProgressContainer(box, 'Firmware OTA');

        // 4-byte size header (little-endian)
        const sizeBuf = new ArrayBuffer(4);
        new DataView(sizeBuf).setUint32(0,data.length,true);
        await writeChar.writeValue(sizeBuf);
        await waitReady();

        // chunks (MTU 517 -> safe payload 512; minus 4 for CRC)
        let offset=0, chunkSize=512-4;
        while(offset<data.length){
          const len=Math.min(chunkSize,data.length-offset);
          const chunk=data.slice(offset,offset+len);
          const crc=crc32(chunk);
          const packet=new Uint8Array(len+4);
          packet.set(chunk);
          new DataView(packet.buffer).setUint32(len,crc,true);
          await writeChar.writeValue(packet);
          await waitReady();
          offset+=len; setProgress(offset,data.length);
        }
        hideProgressContainer();
      }

      async function startIntentionsOTA(btn){
        const path=document.getElementById('intentionsFileSelect').value;
        const resp=await fetch(path); if(!resp.ok){ alert('Intentions file not found'); return; }
        const data=new Uint8Array(await resp.arrayBuffer());
        const filename = path.split('/').pop();

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,INTENTS_CHAR_UUID);
        const box = btn.closest('.uploadBox') || document.getElementById('otaIntsBox');
        showProgressContainer(box, 'Intentions OTA');

        await sendNVS(data,filename);
        hideProgressContainer();
      }

      async function startLanguageOTA(btn){
        const path=document.getElementById('languageFileSelect').value;
        const resp=await fetch(path); if(!resp.ok){ alert('Language file not found'); return; }
        const data=new Uint8Array(await resp.arrayBuffer());
        const filename = path.split('/').pop();

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,LANG_CHAR_UUID);
        const box = btn.closest('.uploadBox') || document.getElementById('otaLangBox');
        showProgressContainer(box, 'Language OTA');

        await sendNVS(data,filename);
        hideProgressContainer();
      }

      function crc32(buf) { let crc=0xFFFFFFFF; for(let b of buf){crc^=b; for(let i=0;i<8;i++) crc=(crc>>>1)^(0xEDB88320&-(crc&1));} return (crc^0xFFFFFFFF)>>>0; }

      async function sendNVS(data,filename){
        // filename header
        const name=new TextEncoder().encode(filename);
        await writeChar.writeValue(name);
        await waitReady();

        let offset=0, chunkSize=320; // a bit smaller than firmware chunks
        while(offset<data.length){
          const len=Math.min(chunkSize,data.length-offset);
          const chunk=data.slice(offset,offset+len);
          const crc=crc32(chunk);
          const packet=new Uint8Array(len+4);
          packet.set(chunk);
          new DataView(packet.buffer).setUint32(len,crc,true);
          await writeChar.writeValue(packet);
          await waitReady();
          offset+=len; updateProgress(offset,data.length);
        }
      }
    </script>
  </body>
</html>