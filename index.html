<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>SmartRosary Installer</title>
    <meta name="description" content="Easily install SmartRosary firmware on the web." />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="color-scheme" content="dark light" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
      *, *::before, *::after { box-sizing: border-box; }
      :root {
        color-scheme: dark;
        /* Landing/dashboard palette */
        --bg: linear-gradient(180deg, #0f5aa0 0%, #0b4f8f 55%, #09457e 100%);
        --text: #eaf0f6;
        --muted: #95a7ba;
        --card: #101722;
        --border: #172231;
        --accent: #0974cc;
        --accent-contrast: #ffffff;
        --bar: #0b4f8f;
        --top-border: rgba(183, 214, 245, 0.25);
        --toolbar-track: rgba(18, 34, 52, 0.55);
        --header-button-bg: #1f2937;
        --header-button-border: #263244;
        --header-button-text: #eaf0f6;
        --control-bg: #101b2c;
        --control-border: #233144;
        --control-text: #eaf0f6;
        --progress-bg: #0d131c;
      }

      html.theme-light {
        color-scheme: light;
        --bg: linear-gradient(180deg, #0f5aa0 0%, #0b4f8f 55%, #09457e 100%);
        --text: #0f172a;
        --muted: #64748b;
        --card: #ffffffcc;
        --border: #cbd5f5;
        --accent: #0974cc;
        --accent-contrast: #ffffff;
        --bar: #0b4f8f;
        --top-border: rgba(183, 214, 245, 0.25);
        --toolbar-track: rgba(18, 34, 52, 0.55);
        --header-button-bg: #f1f5f9;
        --header-button-border: #cbd5f5;
        --header-button-text: #1e3a8a;
        --control-bg: #ffffff;
        --control-border: #cbd5f5;
        --control-text: #0f172a;
        --progress-bg: #e2e8f0;
      }

      html { min-height: 100%; background: var(--bg); }
      body { font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, sans-serif; padding: 0; margin: 0; line-height: 1.4; background: var(--bg); color: var(--text); min-height: 100vh; min-height: 100dvh; display: flex; flex-direction: column; }
      a { color: var(--accent); }
      *, *::before, *::after { box-sizing: border-box; }

      /* Header bar */
      .top-shell { position: sticky; top: 0; z-index: 1000; background: var(--bar); width: 100%; }
      .header-with-lang {
        position: relative;
        display:flex;
        align-items:center;
        justify-content:flex-start;
        padding: 18px 12px 16px;
        background: var(--bar);
        border-bottom: 1px solid var(--top-border);
        width: 100%;
      }
      .header-with-lang h1 {
        margin: 0;
        font-size: 20px;
        font-weight: 700;
        text-align: center;
        flex: 1;
      }
      .deploy-info {
        font-size: 10px;
        letter-spacing: 0.2px;
        color: var(--muted);
        opacity: 0.8;
        pointer-events: none;
        white-space: nowrap;
      }
      .page-footer { padding: 12px; text-align: center; }
      .header-controls { position:absolute; right:12px; display:flex; align-items:center; gap:8px; }
      #themeToggle { padding: 8px 14px; border-radius: 10px; border: 1px solid var(--header-button-border); background: var(--header-button-bg); color: var(--header-button-text); font-weight: 600; cursor: pointer; transition: transform .05s ease; }
      #themeToggle:active { transform: scale(0.98); }
      .header-with-lang select { font-size: 14px; padding: 6px 10px; background: var(--control-bg); color: var(--control-text); border: 1px solid var(--control-border); border-radius: 8px; }
      .toolbar-wrap { padding: 8px 12px 14px; }
      .toolbar { max-width: 720px; margin: 0 auto; display:flex; flex-direction:column; align-items:center; gap:6px; }
      .toolbar-status { font-size: 12px; color: var(--muted); text-align:center; letter-spacing: .02em; }
      .toolbar-progress {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 6px;
        background: var(--toolbar-track);
        overflow: hidden;
        transition: opacity .2s ease;
        opacity: .45;
        pointer-events: none;
      }
      .toolbar-progress .bar { height: 100%; width: 0%; background: var(--accent); transition: width .2s ease; }
      .toolbar-progress.is-active { opacity: 1; }

      /* Layout */
      .content { max-width: 720px; margin: 0 auto; padding: 12px; flex: 1; width: 100%; }
      h2 { margin-top: 1.0em; text-align: center; }

      /* Cards */
      .uploadBox { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 14px; margin-top: 14px; box-shadow: 0 12px 28px rgba(9, 17, 28, 0.18); }
      .footer{text-align: center;}

      /* Controls */
      .controls-container {display: flex; justify-content: center; margin-bottom: 1rem; width: 100%;}
      .controls-table {border-collapse: collapse; width: 100%; table-layout: fixed;}
      .controls-table td {border: none; padding: 0.3rem 0.5rem; vertical-align: middle;}
      label { display: inline-block; width: 160px; max-width: 100%; }
      .content select { padding: 8px 10px; background: var(--control-bg); color: var(--control-text); border:1px solid var(--control-border); border-radius:8px; width: 100%; max-width: 100%; }

      /* Mobile: stack labels and inputs to avoid overflow */
      @media (max-width: 560px) {
        .controls-container { padding: 0 2px; }
        .controls-table, .controls-table tr, .controls-table td { display: block; width: 100%; }
        .controls-table tr { margin-bottom: 10px; }
        label { width: 100%; margin-bottom: 6px; }
      }

      /* Buttons */
      .uploadBtn { cursor: pointer; font-size: 14px; font-weight: 600; padding: 10px 16px; color: var(--accent-contrast); background-color: var(--accent); border: none; border-radius: 10px; transition: transform .05s ease; }
      .uploadBtn:active { transform: scale(0.98); }
      esp-web-install-button::part(button) {
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        padding: 10px 16px;
        color: var(--accent-contrast);
        background-color: var(--accent);
        border: none;
        border-radius: 10px;
        transition: transform .05s ease;
      }
      esp-web-install-button::part(button):active { transform: scale(0.98); }

      html.theme-light body { color: var(--text); }
      html.theme-light .header-with-lang h1 { color: var(--accent-contrast); }
      html.theme-light .toolbar-status { color: var(--accent-contrast); }
      html.theme-light a { color: #1d4ed8; }
      html.theme-light label { color: var(--text); }

      /* Safe-area handling for iOS/modern devices */
      .safe-top-fill { position: fixed; top: 0; left: 0; right: 0; height: 0; background: var(--bar); z-index: 1001; display: none; }
      @supports (padding: env(safe-area-inset-top)) {
        .header-with-lang {
          padding-top: calc(18px + env(safe-area-inset-top));
          padding-left: calc(12px + env(safe-area-inset-left));
          padding-right: calc(12px + env(safe-area-inset-right));
        }
        .toolbar-wrap {
          padding-left: calc(12px + env(safe-area-inset-left));
          padding-right: calc(12px + env(safe-area-inset-right));
        }
        .content {
          padding-left: calc(12px + env(safe-area-inset-left));
          padding-right: calc(12px + env(safe-area-inset-right));
        }
        .safe-top-fill { height: env(safe-area-inset-top); display: block; }
      }
    </style>
    <script>
      (function applyStoredThemeEarly() {
        try {
          const key = 'dashboard-theme';
          const stored = localStorage.getItem(key);
          const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
          const choice = stored === 'light' || stored === 'dark'
            ? stored
            : (prefersLight ? 'light' : 'light');
          if (choice === 'light') {
            document.documentElement.classList.add('theme-light');
          }
        } catch {
          /* ignore storage issues */
        }
      })();
    </script>
    <script>
      const GlobalUI = (() => {
        let statusIdle = 'Ready.';
        let statusEl = null;
        let progressWrap = null;
        let progressBar = null;
        let currentTitle = null;
        let resetTimer = null;

        const refs = () => {
          if (!statusEl) statusEl = document.getElementById('globalStatus');
          if (!progressWrap) progressWrap = document.getElementById('globalProg');
          if (!progressBar && progressWrap) progressBar = progressWrap.querySelector('.bar');
        };

        const setStatus = (text) => {
          refs();
          if (statusEl) statusEl.textContent = text || statusIdle;
        };

        const showProgress = (title) => {
          refs();
          clearTimeout(resetTimer);
          resetTimer = null;
          currentTitle = title || null;
          if (progressWrap) progressWrap.classList.add('is-active');
          if (progressBar) progressBar.style.width = '0%';
          if (title) setStatus(`${title}…`);
          else setStatus();
        };

        const updateProgress = (sent, total) => {
          refs();
          if (!progressBar) return;
          const pct = total ? Math.min(100, Math.round((sent / total) * 100)) : 0;
          progressBar.style.width = `${pct}%`;
          if (currentTitle) setStatus(`${currentTitle} — ${pct}%`);
        };

        const hideProgress = () => {
          refs();
          if (progressWrap) progressWrap.classList.remove('is-active');
          if (progressBar) progressBar.style.width = '0%';
          currentTitle = null;
        };

        const reset = () => {
          hideProgress();
          setStatus();
          clearTimeout(resetTimer);
          resetTimer = null;
        };

        const announce = (message, delay = 3500) => {
          hideProgress();
          if (message) setStatus(message);
          clearTimeout(resetTimer);
          resetTimer = null;
          if (delay && delay > 0) {
            resetTimer = window.setTimeout(() => reset(), delay);
          }
        };

        const error = (message) => {
          hideProgress();
          if (message) setStatus(message);
          clearTimeout(resetTimer);
          resetTimer = null;
        };

        const setIdleText = (text) => {
          statusIdle = text || 'Ready.';
          setStatus();
        };

        return { setStatus, showProgress, updateProgress, hideProgress, reset, announce, error, setIdleText };
      })();
      window.GlobalUI = GlobalUI;
      document.addEventListener('DOMContentLoaded', () => GlobalUI.reset());
    </script>
    <script type="module" src="https://unpkg.com/esp-web-tools@10.1.0/dist/web/install-button.js"></script>
  </head>
	  <body>
	    <div class="safe-top-fill" aria-hidden="true"></div>
	    <header class="header-with-lang">
	      <h1 id="title">SmartRosary Web Installer</h1>
	      <div class="header-controls">
	        <button id="themeToggle" type="button" aria-pressed="false" title="Switch to light mode">Light</button>
	        <select id="uiLangSelect" aria-label="Interface language">
	          <option value="pl" selected>PL</option>
          <option value="en">EN</option>
          <option value="de">DE</option>
        </select>
      </div>
    </header>
    <div class="top-shell">
      <div class="toolbar-wrap">
        <div class="toolbar">
          <div class="toolbar-status" id="globalStatus">Ready.</div>
        </div>
      </div>
      <div id="globalProg" class="toolbar-progress">
        <div class="bar"></div>
      </div>
    </div>
    <div class="content">

      <!-- USB -->
      <div class="uploadBox" id="usbBox">
        <h2 id="usbTitle">Upload firmware v1.13 via USB</h2>
        <div class="controls-container">
          <table class="controls-table">
            <tr>
              <td><label for="language" id="fwLangLabel">Language (firmware data):</label></td>
              <td>
                <select id="language">
                  <option value="pl" selected>Polski</option>
                  <option value="en">English</option>
                  <option value="de">Deutsch</option>
                </select>
              </td>
            </tr>
            <tr>
              <td><label for="intentions" id="intentionsLabel">Intentions:</label></td>
              <td>
	                <select id="intentions">
	                  <option value="none">None</option>
	                  <option value="rosary">Żywy Różaniec 2025 (PMK Düsseldorf)</option>
	                  <option value="rosary2026">Żywy Różaniec 2026 (PMK Düsseldorf)</option>
	                </select>
	              </td>
	            </tr>
	          </table>
	        </div>
        <p align="center">
          <esp-web-install-button>
            <button slot="activate" id="usbInstallActivate" class="uploadBtn" type="button">Connect & Upload</button>
            <span slot="unsupported" id="ewtUnsupported">Your browser does not support installing things on ESP devices. Use Google Chrome or Microsoft Edge.</span>
          </esp-web-install-button>
        </p>
        <div class="footer">USB Installer powered by <a href="https://esphome.github.io/esp-web-tools/">ESP Web Tools</a>.</div>
      </div>

      <!-- Bluetooth: Firmware -->
      <div class="uploadBox" id="otaFwBox">
        <h2 id="otaTitle">Upload firmware v1.13 via Bluetooth</h2>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadFirmwareBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- Bluetooth: Language -->
      <div class="uploadBox" id="otaLangBox">
        <h2 id="langTitle">Upload language via Bluetooth</h2>
        <div style="text-align: center; margin-top: 1em;">
          <select id="languageFileSelect">
            <option value="lang/nvs-lang-pl.bin" selected>Polski</option>
            <option value="lang/nvs-lang-en.bin">English</option>
            <option value="lang/nvs-lang-de.bin">Deutsch</option>
          </select>
        </div>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadLanguageBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- Bluetooth: Intentions -->
      <div class="uploadBox" id="otaIntsBox">
        <h2 id="intentsTitle">Upload intentions via Bluetooth</h2>
        <div style="text-align: center; margin-top: 1em;">
	          <select id="intentionsFileSelect">
	            <option value="intentions/nvs-intentions-pmkdus-2026.bin">Żywy Różaniec 2026 (PMK Düsseldorf)</option>
	            <option value="intentions/nvs-intentions-pmkdus-2025.bin">Żywy Różaniec 2025 (PMK Düsseldorf)</option>
	          </select>
	        </div>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadIntentionsBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

	      <div id="log" style="display:none;"></div>
	    </div>
	    <footer class="page-footer" aria-label="Footer">
	      <div id="deployInfo" class="deploy-info" aria-label="Last deploy"></div>
	    </footer>

	    <!-- Wake lock helpers -->
	    <script src="https://lib.arvancloud.ir/nosleep/0.91.0/NoSleep.min.js"></script>
	    <script>
	      (() => {
        const THEME_KEY = 'dashboard-theme';

        const readStoredTheme = () => {
          try {
            const stored = localStorage.getItem(THEME_KEY);
            return stored === 'light' || stored === 'dark' ? stored : null;
          } catch {
            return null;
          }
        };

        const writeStoredTheme = (value) => {
          try { localStorage.setItem(THEME_KEY, value); } catch {}
        };

        const applyTheme = (mode) => {
          const isLight = mode === 'light';
          const toggle = document.getElementById('themeToggle');
          document.body.classList.toggle('theme-light', isLight);
          document.documentElement.classList.toggle('theme-light', isLight);
          if (toggle) {
            if (window.updateThemeToggleText) {
              window.updateThemeToggleText(isLight);
            } else {
              toggle.textContent = isLight ? 'Dark' : 'Light';
              toggle.title = isLight ? 'Switch to dark mode' : 'Switch to light mode';
              toggle.setAttribute('aria-pressed', String(isLight));
            }
          }
        };

        document.addEventListener('DOMContentLoaded', () => {
          const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
          let theme = readStoredTheme() ?? (prefersLight ? 'light' : 'light');
          applyTheme(theme);

          const toggle = document.getElementById('themeToggle');
          if (toggle) {
            toggle.addEventListener('click', () => {
              theme = theme === 'light' ? 'dark' : 'light';
              applyTheme(theme);
              writeStoredTheme(theme);
            });
          }
        });
      })();
    </script>
    <script>
      // ---------- 0) Firmware version ----------
      const FW_VERSION = "v1.13";

      // ---------- 1) UI i18n ----------
      const i18n = {
        pl: {
          langLabel: "Język",
          title: "SmartRosary Instalator",
          usbTitle: `Wgraj firmware ${FW_VERSION} przez USB`,
          otaTitle: `Wgraj firmware ${FW_VERSION} przez Bluetooth`,
          langTitle: "Wgraj język przez Bluetooth",
          intentsTitle: "Wgraj intencje przez Bluetooth",
          connectUpload: "Połącz i wgraj",
          fwLangLabel: "Język:",
          intentionsLabel: "Intencje:",
          noneOption: "Brak",
          statusReady: "Gotowe.",
          statusConnecting: "Łączenie…",
          statusPreparing: "Połączono. Przygotowywanie transferu…",
          errorNotRosary: "Wybrane urządzenie to nie różaniec (błąd nazwy).",
          errorConsent: "Urządzenie odmówiło zgody lub upłynął czas. Dotknij \"Allow\" i spróbuj ponownie.",
          errorFirmwareMissing: "Nie znaleziono paczki firmware.",
          errorIntentionsMissing: "Nie znaleziono pliku z intencjami.",
          errorLanguageMissing: "Nie znaleziono pliku językowego.",
          errorFirmwareFailed: "Aktualizacja firmware nie powiodła się.",
          errorIntentionsFailed: "Aktualizacja intencji nie powiodła się.",
          errorLanguageFailed: "Aktualizacja języka nie powiodła się.",
          progressFirmware: "Aktualizacja firmware",
          progressIntentions: "Aktualizacja intencji",
          progressLanguage: "Aktualizacja języka",
          completeFirmware: "Aktualizacja firmware zakończona.",
          completeIntentions: "Aktualizacja intencji zakończona.",
          completeLanguage: "Aktualizacja języka zakończona.",
          uiLangAria: "Język interfejsu",
          usbFooter: "Instalator USB wspierany przez",
          themeLightLabel: "Jasny",
          themeDarkLabel: "Ciemny",
          themeLightTitle: "Przełącz na jasny tryb",
          themeDarkTitle: "Przełącz na ciemny tryb"
        },
        de: {
          langLabel: "Sprache",
          title: "SmartRosary Installer",
          usbTitle: `Firmware ${FW_VERSION} per USB hochladen`,
          otaTitle: `Firmware ${FW_VERSION} per Bluetooth hochladen`,
          langTitle: "Sprache per Bluetooth hochladen",
          intentsTitle: "Intentionen per Bluetooth hochladen",
          connectUpload: "Verbinden & Hochladen",
          fwLangLabel: "Sprache:",
          intentionsLabel: "Intentionen:",
          noneOption: "Keine",
          statusReady: "Bereit.",
          statusConnecting: "Verbinden…",
          statusPreparing: "Verbunden. Übertragung wird vorbereitet…",
          errorNotRosary: "Ausgewähltes Gerät ist kein Rosenkranz (Namensprüfung fehlgeschlagen).",
          errorConsent: "Gerät verweigert Zustimmung oder Zeitüberschreitung. Bitte \"Allow\" am Gerät wählen und erneut versuchen.",
          errorFirmwareMissing: "Firmware-Paket nicht gefunden.",
          errorIntentionsMissing: "Intentionen-Datei nicht gefunden.",
          errorLanguageMissing: "Sprachdatei nicht gefunden.",
          errorFirmwareFailed: "Firmware-Update fehlgeschlagen.",
          errorIntentionsFailed: "Intentionen-Update fehlgeschlagen.",
          errorLanguageFailed: "Sprach-Update fehlgeschlagen.",
          progressFirmware: "Firmware-Update",
          progressIntentions: "Intentionen-Update",
          progressLanguage: "Sprach-Update",
          completeFirmware: "Firmware-Update abgeschlossen.",
          completeIntentions: "Intentionen-Update abgeschlossen.",
          completeLanguage: "Sprach-Update abgeschlossen.",
          uiLangAria: "Interface-Sprache",
          usbFooter: "USB-Installer bereitgestellt von",
          themeLightLabel: "Hell",
          themeDarkLabel: "Dunkel",
          themeLightTitle: "Auf helles Design umschalten",
          themeDarkTitle: "Auf dunkles Design umschalten",
          unsupportedMsg: "Ihr Browser unterstützt die Installation auf ESP-Geräten nicht. Bitte Google Chrome oder Microsoft Edge verwenden."
        },
        en: {
          langLabel: "Language",
          title: "SmartRosary Installer",
          usbTitle: `Upload firmware ${FW_VERSION} via USB`,
          otaTitle: `Upload firmware ${FW_VERSION} via Bluetooth`,
          langTitle: "Upload language via Bluetooth",
          intentsTitle: "Upload intentions via Bluetooth",
          connectUpload: "Connect & Upload",
          fwLangLabel: "Language:",
          intentionsLabel: "Intentions:",
          noneOption: "None",
          statusReady: "Ready.",
          statusConnecting: "Connecting…",
          statusPreparing: "Connected. Preparing transfer…",
          errorNotRosary: "Picked device is not a rosary (name check failed).",
          errorConsent: "Device denied consent or timed out. Please tap \"Allow\" on the device and try again.",
          errorFirmwareMissing: "Firmware package not found.",
          errorIntentionsMissing: "Intentions file not found.",
          errorLanguageMissing: "Language file not found.",
          errorFirmwareFailed: "Bluetooth firmware upload failed.",
          errorIntentionsFailed: "Bluetooth intentions upload failed.",
          errorLanguageFailed: "Bluetooth language upload failed.",
          progressFirmware: "Bluetooth firmware upload",
          progressIntentions: "Bluetooth intentions upload",
          progressLanguage: "Bluetooth language upload",
          completeFirmware: "Bluetooth firmware upload complete.",
          completeIntentions: "Bluetooth intentions upload complete.",
          completeLanguage: "Bluetooth language upload complete.",
          uiLangAria: "Interface language",
          usbFooter: "USB Installer powered by",
          themeLightLabel: "Light",
          themeDarkLabel: "Dark",
          themeLightTitle: "Switch to light mode",
          themeDarkTitle: "Switch to dark mode",
          unsupportedMsg: "Your browser does not support installing things on ESP devices. Use Google Chrome or Microsoft Edge."
        },
        pl: {
          langLabel: "Język",
          title: "SmartRosary Instalator",
          usbTitle: `Wgraj firmware ${FW_VERSION} przez USB`,
          otaTitle: `Wgraj firmware ${FW_VERSION} przez Bluetooth`,
          langTitle: "Wgraj język przez Bluetooth",
          intentsTitle: "Wgraj intencje przez Bluetooth",
          connectUpload: "Połącz i wgraj",
          fwLangLabel: "Język:",
          intentionsLabel: "Intencje:",
          noneOption: "Brak",
          statusReady: "Gotowe.",
          statusConnecting: "Łączenie…",
          statusPreparing: "Połączono. Przygotowywanie transferu…",
          errorNotRosary: "Wybrane urządzenie to nie różaniec (błąd nazwy).",
          errorConsent: "Urządzenie odmówiło zgody lub upłynął czas. Dotknij \"Allow\" i spróbuj ponownie.",
          errorFirmwareMissing: "Nie znaleziono paczki firmware.",
          errorIntentionsMissing: "Nie znaleziono pliku z intencjami.",
          errorLanguageMissing: "Nie znaleziono pliku językowego.",
          errorFirmwareFailed: "Aktualizacja firmware nie powiodła się.",
          errorIntentionsFailed: "Aktualizacja intencji nie powiodła się.",
          errorLanguageFailed: "Aktualizacja języka nie powiodła się.",
          progressFirmware: "Aktualizacja firmware",
          progressIntentions: "Aktualizacja intencji",
          progressLanguage: "Aktualizacja języka",
          completeFirmware: "Aktualizacja firmware zakończona.",
          completeIntentions: "Aktualizacja intencji zakończona.",
          completeLanguage: "Aktualizacja języka zakończona.",
          uiLangAria: "Język interfejsu",
          usbFooter: "Instalator USB wspierany przez",
          themeLightLabel: "Jasny",
          themeDarkLabel: "Ciemny",
          themeLightTitle: "Przełącz na jasny tryb",
          themeDarkTitle: "Przełącz na ciemny tryb",
          unsupportedMsg: "Twoja przeglądarka nie obsługuje instalacji na urządzeniach ESP. Użyj Google Chrome lub Microsoft Edge."
        }
      };


      let currentLang = 'pl';

      function getTranslation(langKey = currentLang) {
        return i18n[langKey] || i18n.en;
      }

      function t(key) {
        const dict = getTranslation();
        return dict[key] || i18n.en[key] || '';
      }

      function updateThemeToggleText(isLight) {
        const toggle = document.getElementById('themeToggle');
        if (!toggle) return;
        const dict = getTranslation();
        toggle.textContent = isLight ? dict.themeDarkLabel : dict.themeLightLabel;
        toggle.title = isLight ? dict.themeDarkTitle : dict.themeLightTitle;
        toggle.setAttribute('aria-pressed', String(isLight));
      }
      window.updateThemeToggleText = updateThemeToggleText;

      function setLanguage(lang) {
        currentLang = i18n[lang] ? lang : 'en';
        const dict = getTranslation();

        document.documentElement.lang = currentLang;
        document.title = dict.title;

        const uiLangSelect = document.getElementById("uiLangSelect");
        if (uiLangSelect) {
          uiLangSelect.setAttribute("aria-label", dict.uiLangAria);
          uiLangSelect.value = currentLang;
        }

        const titleEl = document.getElementById("title");
        if (titleEl) titleEl.textContent = dict.title;
        const usbTitle = document.getElementById("usbTitle");
        if (usbTitle) usbTitle.textContent = dict.usbTitle;
        const otaTitle = document.getElementById("otaTitle");
        if (otaTitle) otaTitle.textContent = dict.otaTitle;
        const langTitle = document.getElementById("langTitle");
        if (langTitle) langTitle.textContent = dict.langTitle;
        const intentsTitle = document.getElementById("intentsTitle");
        if (intentsTitle) intentsTitle.textContent = dict.intentsTitle;
        const fwLabel = document.getElementById("fwLangLabel");
        if (fwLabel) fwLabel.textContent = dict.fwLangLabel;
        const intentsLabel = document.getElementById("intentionsLabel");
        if (intentsLabel) intentsLabel.textContent = dict.intentionsLabel;

        const noneOption = document.querySelector('#intentions option[value="none"]');
        if (noneOption) noneOption.textContent = dict.noneOption;

        const statusBar = document.getElementById("globalStatus");
        if (statusBar) statusBar.textContent = dict.statusReady;
        if (window.GlobalUI && GlobalUI.setIdleText) GlobalUI.setIdleText(dict.statusReady);

        document.querySelectorAll(".uploadBtn").forEach(btn => btn.textContent = dict.connectUpload);

        const footer = document.querySelector("#usbBox .footer");
        if (footer) {
          const link = footer.querySelector("a");
          footer.textContent = `${dict.usbFooter} `;
          if (link) footer.appendChild(link);
          footer.appendChild(document.createTextNode("."));
        }

        const unsupported = document.getElementById("ewtUnsupported");
        if (unsupported) unsupported.textContent = dict.unsupportedMsg || i18n.en.unsupportedMsg;
      }

      document.addEventListener("DOMContentLoaded", () => {
        const uiLangSelect = document.getElementById("uiLangSelect");
        const initialLang = (uiLangSelect && uiLangSelect.value) ? uiLangSelect.value : currentLang;
        setLanguage(initialLang);

        const deployInfo = document.getElementById("deployInfo");
        if (deployInfo) {
          const ts = new Date(document.lastModified);
          const formatted = isNaN(ts.getTime())
            ? ""
            : ts.toLocaleString(undefined, {
                year: "numeric",
                month: "short",
                day: "numeric",
                hour: "2-digit",
                minute: "2-digit"
              });
          deployInfo.textContent = formatted ? `Last deploy: ${formatted}` : "";
        }

        if (uiLangSelect) {
          uiLangSelect.addEventListener("change", e => setLanguage(e.target.value));
        }
      });

      // ---------- 2) Screen wake-lock ----------
      let wakeLock = null;
      async function enableWakeLock() {
        try {
          if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
            wakeLock.addEventListener('release', () => console.log('Screen Wake Lock released'));
          }
        } catch (err) {
          console.warn('WakeLock error:', err.name, err.message);
        }
      }
      let noSleep = null;
      function preventStandby() {
        enableWakeLock();
        try {
          if (!noSleep && typeof NoSleep !== 'undefined') {
            noSleep = new NoSleep();
          }
          if (noSleep) noSleep.enable();
        } catch {}
      }
      document.addEventListener('visibilitychange', () => {
        if (wakeLock !== null && document.visibilityState === 'visible') enableWakeLock();
      });
    </script>
    <!-- USB manifest + Bluetooth logic -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        customElements.whenDefined("esp-web-install-button").then(() => {
          const btn     = document.querySelector("esp-web-install-button");
          const selLang = document.getElementById("language");
          const selInt  = document.getElementById("intentions");
          const origin  = window.location.origin;

          // On-disk locations (adjust to your structure)
          const firmwareParts = [
            { path: "smartrosary-web-installer/firmware/bootloader.bin", offset: 0x000000 },
            { path: "smartrosary-web-installer/firmware/partitions.bin", offset: 0x008000 },
            { path: "smartrosary-web-installer/firmware/boot_app0.bin",  offset: 0x00E000 },
            { path: "smartrosary-web-installer/firmware/firmware.bin",   offset: 0x010000 },
            { path: "smartrosary-web-installer/spiffs/wallpaper.bin",    offset: 0x323000 }
          ];

          const languages = {
            pl: { name: "Polski",  path: "smartrosary-web-installer/lang/nvs-lang-pl.bin", offset: 0x2F5000 },
            en: { name: "English", path: "smartrosary-web-installer/lang/nvs-lang-en.bin", offset: 0x2F5000 },
            de: { name: "Deutsch", path: "smartrosary-web-installer/lang/nvs-lang-de.bin", offset: 0x2F5000 }
          };

	          const intentions = {
	            none: null,
	            rosary: {
	              name: "Żywy Różaniec 2025",
	              path: "smartrosary-web-installer/intentions/nvs-intentions-pmkdus-2025.bin",
	              offset: 0x2F0000
	            },
	            rosary2026: {
	              name: "Żywy Różaniec 2026",
	              path: "smartrosary-web-installer/intentions/nvs-intentions-pmkdus-2026.bin",
	              offset: 0x2F0000
	            }
	          };

          function buildManifest() {
            if (btn._blobUrl) URL.revokeObjectURL(btn._blobUrl);

            const rawParts = [...firmwareParts];

            // include chosen language
            const lang = languages[selLang.value];
            rawParts.splice(1, 0, { path: lang.path, offset: lang.offset });

            // include chosen intentions (optional)
            const intent = intentions[selInt.value];
            if (intent) rawParts.push({ path: intent.path, offset: intent.offset });

            // absolute URLs
            const parts = rawParts.map(p => ({
              offset: p.offset,
              path: p.path.startsWith("http") ? p.path : `${origin}/${p.path}`
            }));

            const manifest = {
              name:    `SmartRosary (${lang.name}${intent ? " / " + intent.name : ""})`,
              version: FW_VERSION,     // <-- uses single version variable
              funding_url: "",
              new_install_prompt_erase: true,
              builds: [{ chipFamily: "ESP32-C3", improv: false, parts }]
            };

            const blobUrl = URL.createObjectURL(new Blob([JSON.stringify(manifest)], { type: "application/json" }));
            btn._blobUrl = blobUrl;
            btn.manifest = blobUrl;
            console.log("Using manifest blob URL:", blobUrl);
          }

          selLang.addEventListener("change", buildManifest);
          selInt .addEventListener("change", buildManifest);
          buildManifest();
        });
      });
    </script>

    <!-- Bluetooth uploader (firmware / lang / intentions) -->
    <script>
      // UUIDs — MUST match firmware (lowercase)
      const SERVICE_UUID       = '12345678-1234-5678-1234-56789abcdef0';
      const FIRMWARE_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef1';
      const INTENTS_CHAR_UUID  = '12345678-1234-5678-1234-56789abcde10';
      const LANG_CHAR_UUID     = '12345678-1234-5678-1234-56789abcde20';
      const STATUS_CHAR_UUID   = '12345678-1234-5678-1234-56789abcdef2';
      const INFO_CTRL_UUID     = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e10ff';  // <— ADD THIS
      

      let device, writeChar, statusChar;
      let ready = true;

      document.getElementById('uploadFirmwareBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startFirmwareBluetooth(ev.currentTarget); }
        catch (e) {
          const msg = e.message || t('errorFirmwareFailed');
          if (window.GlobalUI) GlobalUI.error(msg);
          alert(msg);
        }
      });
      document.getElementById('uploadIntentionsBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startIntentionsBluetooth(ev.currentTarget); }
        catch (e) {
          const msg = e.message || t('errorIntentionsFailed');
          if (window.GlobalUI) GlobalUI.error(msg);
          alert(msg);
        }
      });
      document.getElementById('uploadLanguageBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startLanguageBluetooth(ev.currentTarget); }
        catch (e) {
          const msg = e.message || t('errorLanguageFailed');
          if (window.GlobalUI) GlobalUI.error(msg);
          alert(msg);
        }
      });

      async function helloAndAwaitConsent(svc) {
        // Get control + status characteristics
        const ctrlChar  = await svc.getCharacteristic(INFO_CTRL_UUID);
        const statChar  = await svc.getCharacteristic(STATUS_CHAR_UUID);

        // Start notifications (we’ll also keep this statusChar as the global one)
        await statChar.startNotifications();

        // Wait for 0xA1 (allow) or 0xA0 (deny)
        const allowed = await new Promise(async (resolve) => {
          const onStatus = (ev) => {
            const v = new Uint8Array(ev.target.value.buffer)[0];
            if (v === 0xA1 || v === 0xA0) {
              statChar.removeEventListener('characteristicvaluechanged', onStatus);
              resolve(v === 0xA1);
            }
          };
          statChar.addEventListener('characteristicvaluechanged', onStatus);

          // Send HELLO_WEB (0x41) to pop consent on the device
          await ctrlChar.writeValue(Uint8Array.of(0x41));

          // Hard timeout to avoid hanging forever
          setTimeout(() => {
            try { statChar.removeEventListener('characteristicvaluechanged', onStatus); } catch {}
            resolve(false);
          }, 25000);
        });

        return allowed;
      }

      async function waitReady(){ while(!ready) await new Promise(r=>setTimeout(r,50)); ready=false; }

      // More robust BLE discovery: prefer service filter, fallback to acceptAllDevices
      async function connectBLE(svcUuid, charUuid){
        if (window.GlobalUI) GlobalUI.setStatus(t('statusConnecting'));
        // 1) Pick device (prefer service filter; fallback acceptAllDevices)
        try {
          device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [svcUuid] }],
            optionalServices: [svcUuid, SERVICE_UUID] // ensure our main service is always discoverable
          });
        } catch (e) {
          device = await navigator.bluetooth.requestDevice({
            acceptAllDevices: true,
            optionalServices: [svcUuid, SERVICE_UUID]
          });
          if (!device.name || !device.name.toLowerCase().startsWith('rosary')) {
            throw new Error(t('errorNotRosary'));
          }
        }

        // 2) Connect
        const gatt = await device.gatt.connect();

        // 3) Always get the main Bluetooth service (it contains STATUS + INFO_CTRL)
        const svc = await gatt.getPrimaryService(SERVICE_UUID);

        // 4) Ask for consent (HELLO_WEB -> LVGL “Allow Web” modal on device)
        const consent = await helloAndAwaitConsent(svc);
        if (!consent) {
          try {
            // optional: tell device we’re backing out
            const ctrl = await svc.getCharacteristic(INFO_CTRL_UUID);
            await ctrl.writeValue(Uint8Array.of(0x42)); // CANCEL_WEB
          } catch {}
          throw new Error(t('errorConsent'));
        }

        // 5) Now it’s safe to use your target write characteristic
        //    (firmware / language / intentions are separate chars under the same service)
        writeChar  = await svc.getCharacteristic(charUuid);

        // 6) Keep a global statusChar for “ready/ACK” pacing (also used above in consent)
        try {
          statusChar = await svc.getCharacteristic(STATUS_CHAR_UUID);
          statusChar.addEventListener('characteristicvaluechanged', () => { ready = true; });
          // It’s already started in helloAndAwaitConsent, but starting again is harmless
          await statusChar.startNotifications();
        } catch {
          // optional
        }
        if (window.GlobalUI) GlobalUI.setStatus(t('statusPreparing'));
      }

      function setProgress(sent,total){
        if (window.GlobalUI) GlobalUI.updateProgress(sent,total);
      }

      async function startFirmwareBluetooth(btn){
        const resp = await fetch('firmware/firmware.bin');
        if(!resp.ok){
          const msg = t('errorFirmwareMissing');
          if (window.GlobalUI) GlobalUI.error(msg);
          alert(msg);
          return;
        }
        const data = new Uint8Array(await resp.arrayBuffer());

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,FIRMWARE_CHAR_UUID);
        if (window.GlobalUI) GlobalUI.showProgress(t('progressFirmware'));

        // 4-byte size header (little-endian)
        const sizeBuf = new ArrayBuffer(4);
        new DataView(sizeBuf).setUint32(0,data.length,true);
        await writeChar.writeValue(sizeBuf);
        await waitReady();

        // chunks (MTU 517 -> safe payload 512; minus 4 for CRC)
        let offset=0, chunkSize=512-4;
        while(offset<data.length){
          const len=Math.min(chunkSize,data.length-offset);
          const chunk=data.slice(offset,offset+len);
          const crc=crc32(chunk);
          const packet=new Uint8Array(len+4);
          packet.set(chunk);
          new DataView(packet.buffer).setUint32(len,crc,true);
          await writeChar.writeValue(packet);
          await waitReady();
          offset+=len; setProgress(offset,data.length);
        }
        if (window.GlobalUI) GlobalUI.announce(t('completeFirmware'));
      }

      async function startIntentionsBluetooth(btn){
        const path=document.getElementById('intentionsFileSelect').value;
        const resp=await fetch(path);
        if(!resp.ok){
          const msg = t('errorIntentionsMissing');
          if (window.GlobalUI) GlobalUI.error(msg);
          alert(msg);
          return;
        }
        const data=new Uint8Array(await resp.arrayBuffer());
        const filename = path.split('/').pop();

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,INTENTS_CHAR_UUID);
        if (window.GlobalUI) GlobalUI.showProgress(t('progressIntentions'));

        await sendNVS(data,filename);
        if (window.GlobalUI) GlobalUI.announce(t('completeIntentions'));
      }

      async function startLanguageBluetooth(btn){
        const path=document.getElementById('languageFileSelect').value;
        const resp=await fetch(path);
        if(!resp.ok){
          const msg = t('errorLanguageMissing');
          if (window.GlobalUI) GlobalUI.error(msg);
          alert(msg);
          return;
        }
        const data=new Uint8Array(await resp.arrayBuffer());
        const filename = path.split('/').pop();

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,LANG_CHAR_UUID);
        if (window.GlobalUI) GlobalUI.showProgress(t('progressLanguage'));

        await sendNVS(data,filename);
        if (window.GlobalUI) GlobalUI.announce(t('completeLanguage'));
      }

      function crc32(buf) { let crc=0xFFFFFFFF; for(let b of buf){crc^=b; for(let i=0;i<8;i++) crc=(crc>>>1)^(0xEDB88320&-(crc&1));} return (crc^0xFFFFFFFF)>>>0; }

      async function sendNVS(data,filename){
        // filename header
        const name=new TextEncoder().encode(filename);
        await writeChar.writeValue(name);
        await waitReady();

        let offset=0, chunkSize=320; // a bit smaller than firmware chunks
        while(offset<data.length){
          const len=Math.min(chunkSize,data.length-offset);
          const chunk=data.slice(offset,offset+len);
          const crc=crc32(chunk);
          const packet=new Uint8Array(len+4);
          packet.set(chunk);
          new DataView(packet.buffer).setUint32(len,crc,true);
          await writeChar.writeValue(packet);
          await waitReady();
          offset+=len; setProgress(offset,data.length);
        }
      }
    </script>
  </body>
</html>
