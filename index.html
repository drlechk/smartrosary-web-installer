<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>SmartRosary Installer</title>
    <meta name="description" content="Easily install SmartRosary firmware on the web." />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="color-scheme" content="dark light" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
      *, *::before, *::after { box-sizing: border-box; }
      :root {
        color-scheme: dark;
        /* Landing/dashboard palette */
        --bg: linear-gradient(180deg, #0f5aa0 0%, #0b4f8f 55%, #09457e 100%);
        --text: #eaf0f6;
        --muted: #95a7ba;
        --card: #101722;
        --border: #172231;
        --accent: #0974cc;
        --accent-contrast: #ffffff;
        --bar: #0b4f8f;
        --top-border: rgba(183, 214, 245, 0.25);
        --toolbar-track: rgba(18, 34, 52, 0.55);
        --header-button-bg: #1f2937;
        --header-button-border: #263244;
        --header-button-text: #eaf0f6;
        --control-bg: #101b2c;
        --control-border: #233144;
        --control-text: #eaf0f6;
        --progress-bg: #0d131c;
      }

      html.theme-light {
        color-scheme: light;
        --bg: linear-gradient(180deg, #f5f9ff 0%, #e9f1ff 55%, #dde9ff 100%);
        --text: #0f172a;
        --muted: #64748b;
        --card: #ffffffcc;
        --border: #cbd5f5;
        --accent: #1d4ed8;
        --accent-contrast: #ffffff;
        --bar: #dbeafe;
        --top-border: rgba(148, 163, 184, 0.35);
        --toolbar-track: rgba(191, 209, 231, 0.6);
        --header-button-bg: #f1f5f9;
        --header-button-border: #cbd5f5;
        --header-button-text: #1e3a8a;
        --control-bg: #ffffff;
        --control-border: #cbd5f5;
        --control-text: #0f172a;
        --progress-bg: #e2e8f0;
      }

      html { min-height: 100%; background: var(--bg); }
      body { font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, sans-serif; padding: 0; margin: 0; line-height: 1.4; background: var(--bg); color: var(--text); min-height: 100vh; min-height: 100dvh; display: flex; flex-direction: column; }
      a { color: var(--accent); }
      *, *::before, *::after { box-sizing: border-box; }

      /* Header bar */
      .top-shell { position: sticky; top: 0; z-index: 1000; background: var(--bar); width: 100%; }
      .header-with-lang {
        position: relative;
        display:flex;
        align-items:center;
        justify-content:flex-start;
        padding: 18px 12px 16px;
        background: var(--bar);
        border-bottom: 1px solid var(--top-border);
        width: 100%;
      }
      .header-with-lang h1 { margin:0; font-size: 20px; font-weight: 700; text-align:left; }
      .header-controls { position:absolute; right:12px; display:flex; align-items:center; gap:8px; }
      #themeToggle { padding: 8px 14px; border-radius: 10px; border: 1px solid var(--header-button-border); background: var(--header-button-bg); color: var(--header-button-text); font-weight: 600; cursor: pointer; transition: transform .05s ease; }
      #themeToggle:active { transform: scale(0.98); }
      .header-with-lang select { font-size: 14px; padding: 6px 10px; background: var(--control-bg); color: var(--control-text); border: 1px solid var(--control-border); border-radius: 8px; }
      .toolbar-wrap { padding: 8px 12px 14px; }
      .toolbar { max-width: 720px; margin: 0 auto; display:flex; flex-direction:column; align-items:center; gap:6px; }
      .toolbar-status { font-size: 12px; color: var(--muted); text-align:center; letter-spacing: .02em; }
      .toolbar-progress {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 6px;
        background: var(--toolbar-track);
        overflow: hidden;
        transition: opacity .2s ease;
        opacity: .45;
        pointer-events: none;
      }
      .toolbar-progress .bar { height: 100%; width: 0%; background: var(--accent); transition: width .2s ease; }
      .toolbar-progress.is-active { opacity: 1; }

      /* Layout */
      .content { max-width: 720px; margin: 0 auto; padding: 12px; flex: 1; width: 100%; }
      h2 { margin-top: 1.0em; text-align: center; }

      /* Cards */
      .uploadBox { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 14px; margin-top: 14px; box-shadow: 0 12px 28px rgba(9, 17, 28, 0.18); }
      .footer{text-align: center;}

      /* Controls */
      .controls-container {display: flex; justify-content: center; margin-bottom: 1rem; width: 100%;}
      .controls-table {border-collapse: collapse; width: 100%; table-layout: fixed;}
      .controls-table td {border: none; padding: 0.3rem 0.5rem; vertical-align: middle;}
      label { display: inline-block; width: 160px; max-width: 100%; }
      .content select { padding: 8px 10px; background: var(--control-bg); color: var(--control-text); border:1px solid var(--control-border); border-radius:8px; width: 100%; max-width: 100%; }

      /* Mobile: stack labels and inputs to avoid overflow */
      @media (max-width: 560px) {
        .controls-container { padding: 0 2px; }
        .controls-table, .controls-table tr, .controls-table td { display: block; width: 100%; }
        .controls-table tr { margin-bottom: 10px; }
        label { width: 100%; margin-bottom: 6px; }
      }

      /* Buttons */
      .uploadBtn { cursor: pointer; font-size: 14px; font-weight: 600; padding: 10px 16px; color: var(--accent-contrast); background-color: var(--accent); border: none; border-radius: 10px; transition: transform .05s ease; }
      .uploadBtn:active { transform: scale(0.98); }

      html.theme-light body { color: var(--text); }
      html.theme-light .header-with-lang h1 { color: #1e3a8a; }
      html.theme-light a { color: #1d4ed8; }
      html.theme-light label { color: var(--text); }

      /* Safe-area handling for iOS/modern devices */
      .safe-top-fill { position: fixed; top: 0; left: 0; right: 0; height: 0; background: var(--bar); z-index: 1001; display: none; }
      @supports (padding: env(safe-area-inset-top)) {
        .header-with-lang {
          padding-top: calc(18px + env(safe-area-inset-top));
          padding-left: calc(12px + env(safe-area-inset-left));
          padding-right: calc(12px + env(safe-area-inset-right));
        }
        .toolbar-wrap {
          padding-left: calc(12px + env(safe-area-inset-left));
          padding-right: calc(12px + env(safe-area-inset-right));
        }
        .content {
          padding-left: calc(12px + env(safe-area-inset-left));
          padding-right: calc(12px + env(safe-area-inset-right));
        }
        .safe-top-fill { height: env(safe-area-inset-top); display: block; }
      }
    </style>
    <script>
      (function applyStoredThemeEarly() {
        try {
          const key = 'dashboard-theme';
          const stored = localStorage.getItem(key);
          const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
          const choice = stored === 'light' || stored === 'dark'
            ? stored
            : (prefersLight ? 'light' : 'light');
          if (choice === 'light') {
            document.documentElement.classList.add('theme-light');
          }
        } catch {
          /* ignore storage issues */
        }
      })();
    </script>
    <script>
      const GlobalUI = (() => {
        const STATUS_IDLE = 'Ready.';
        let statusEl = null;
        let progressWrap = null;
        let progressBar = null;
        let currentTitle = null;
        let resetTimer = null;

        const refs = () => {
          if (!statusEl) statusEl = document.getElementById('globalStatus');
          if (!progressWrap) progressWrap = document.getElementById('globalProg');
          if (!progressBar && progressWrap) progressBar = progressWrap.querySelector('.bar');
        };

        const setStatus = (text) => {
          refs();
          if (statusEl) statusEl.textContent = text || STATUS_IDLE;
        };

        const showProgress = (title) => {
          refs();
          clearTimeout(resetTimer);
          resetTimer = null;
          currentTitle = title || null;
          if (progressWrap) progressWrap.classList.add('is-active');
          if (progressBar) progressBar.style.width = '0%';
          if (title) setStatus(`${title}…`);
          else setStatus();
        };

        const updateProgress = (sent, total) => {
          refs();
          if (!progressBar) return;
          const pct = total ? Math.min(100, Math.round((sent / total) * 100)) : 0;
          progressBar.style.width = `${pct}%`;
          if (currentTitle) setStatus(`${currentTitle} — ${pct}%`);
        };

        const hideProgress = () => {
          refs();
          if (progressWrap) progressWrap.classList.remove('is-active');
          if (progressBar) progressBar.style.width = '0%';
          currentTitle = null;
        };

        const reset = () => {
          hideProgress();
          setStatus();
          clearTimeout(resetTimer);
          resetTimer = null;
        };

        const announce = (message, delay = 3500) => {
          hideProgress();
          if (message) setStatus(message);
          clearTimeout(resetTimer);
          resetTimer = null;
          if (delay && delay > 0) {
            resetTimer = window.setTimeout(() => reset(), delay);
          }
        };

        const error = (message) => {
          hideProgress();
          if (message) setStatus(message);
          clearTimeout(resetTimer);
          resetTimer = null;
        };

        return { setStatus, showProgress, updateProgress, hideProgress, reset, announce, error };
      })();
      window.GlobalUI = GlobalUI;
      document.addEventListener('DOMContentLoaded', () => GlobalUI.reset());
    </script>
    <script type="module" src="https://unpkg.com/esp-web-tools@10.1.0/dist/web/install-button.js"></script>
  </head>
  <body>
    <div class="safe-top-fill" aria-hidden="true"></div>
    <header class="header-with-lang">
      <h1 id="title">SmartRosary Web Installer</h1>
      <div class="header-controls">
        <button id="themeToggle" type="button" aria-pressed="false" title="Switch to light mode">Light</button>
        <select id="uiLangSelect" aria-label="Interface language">
          <option value="pl" selected>PL</option>
          <option value="en">EN</option>
          <option value="de">DE</option>
        </select>
      </div>
    </header>
    <div class="top-shell">
      <div class="toolbar-wrap">
        <div class="toolbar">
          <div class="toolbar-status" id="globalStatus">Ready.</div>
        </div>
      </div>
      <div id="globalProg" class="toolbar-progress">
        <div class="bar"></div>
      </div>
    </div>
    <div class="content">

      <!-- USB -->
      <div class="uploadBox" id="usbBox">
        <h2 id="usbTitle">Upload firmware v1.0 via USB</h2>
        <div class="controls-container">
          <table class="controls-table">
            <tr>
              <td><label for="language" id="fwLangLabel">Language (firmware data):</label></td>
              <td>
                <select id="language">
                  <option value="pl" selected>Polski</option>
                  <option value="en">English</option>
                  <option value="de">Deutsch</option>
                </select>
              </td>
            </tr>
            <tr>
              <td><label for="intentions" id="intentionsLabel">Intentions:</label></td>
              <td>
                <select id="intentions">
                  <option value="none">None</option>
                  <option value="rosary">Żywy Różaniec 2025 (PMK Düsseldorf)</option>
                </select>
              </td>
            </tr>
          </table>
        </div>
        <p align="center"><esp-web-install-button></esp-web-install-button></p>
        <div class="footer">USB Installer powered by <a href="https://esphome.github.io/esp-web-tools/">ESP Web Tools</a>.</div>
      </div>

      <!-- OTA: Firmware -->
      <div class="uploadBox" id="otaFwBox">
        <h2 id="otaTitle">Upload firmware v1.0 via OTA</h2>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadFirmwareBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- OTA: Language -->
      <div class="uploadBox" id="otaLangBox">
        <h2 id="langTitle">Upload language via OTA</h2>
        <div style="text-align: center; margin-top: 1em;">
          <select id="languageFileSelect">
            <option value="lang/nvs-lang-pl.bin" selected>Polski</option>
            <option value="lang/nvs-lang-en.bin">English</option>
            <option value="lang/nvs-lang-de.bin">Deutsch</option>
          </select>
        </div>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadLanguageBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- OTA: Intentions -->
      <div class="uploadBox" id="otaIntsBox">
        <h2 id="intentsTitle">Upload intentions via OTA</h2>
        <div style="text-align: center; margin-top: 1em;">
          <select id="intentionsFileSelect">
            <option value="intentions/nvs-intentions-pmkdus-2025.bin">Żywy Różaniec 2025 (PMK Düsseldorf)</option>
          </select>
        </div>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadIntentionsBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <div id="log" style="display:none;"></div>
    </div>

    <!-- Wake lock helpers -->
    <script src="https://lib.arvancloud.ir/nosleep/0.91.0/NoSleep.min.js"></script>
    <script>
      (() => {
        const THEME_KEY = 'dashboard-theme';

        const readStoredTheme = () => {
          try {
            const stored = localStorage.getItem(THEME_KEY);
            return stored === 'light' || stored === 'dark' ? stored : null;
          } catch {
            return null;
          }
        };

        const writeStoredTheme = (value) => {
          try { localStorage.setItem(THEME_KEY, value); } catch {}
        };

        const applyTheme = (mode) => {
          const isLight = mode === 'light';
          const toggle = document.getElementById('themeToggle');
          document.body.classList.toggle('theme-light', isLight);
          document.documentElement.classList.toggle('theme-light', isLight);
          if (toggle) {
            toggle.textContent = isLight ? 'Dark' : 'Light';
            toggle.title = isLight ? 'Switch to dark mode' : 'Switch to light mode';
            toggle.setAttribute('aria-pressed', String(isLight));
          }
        };

        document.addEventListener('DOMContentLoaded', () => {
          const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
          let theme = readStoredTheme() ?? (prefersLight ? 'light' : 'light');
          applyTheme(theme);

          const toggle = document.getElementById('themeToggle');
          if (toggle) {
            toggle.addEventListener('click', () => {
              theme = theme === 'light' ? 'dark' : 'light';
              applyTheme(theme);
              writeStoredTheme(theme);
            });
          }
        });
      })();
    </script>
    <script>
      // ---------- 0) Firmware version ----------
      const FW_VERSION = "v1.0";

      // ---------- 1) UI i18n ----------
      const i18n = {
        pl: {
          langLabel: "Język",
          title: "SmartRosary Instalator",
          usbTitle: `Wgraj firmware ${FW_VERSION} przez USB`,
          otaTitle: `Wgraj firmware ${FW_VERSION} przez Bluetooth`,
          langTitle: "Wgraj język przez Bluetooth",
          intentsTitle: "Wgraj intencje przez Bluetooth",
          connectUpload: "Połącz i wgraj",
          fwLangLabel: "Język:",
          intentionsLabel: "Intencje:"
        },
        de: {
          langLabel: "Sprache",
          title: "SmartRosary Installer",
          usbTitle: `Firmware ${FW_VERSION} per USB hochladen`,
          otaTitle: `Firmware ${FW_VERSION} per Bluetooth hochladen`,
          langTitle: "Sprache per Bluetooth hochladen",
          intentsTitle: "Intentionen per Bluetooth hochladen",
          connectUpload: "Verbinden & Hochladen",
          fwLangLabel: "Sprache:",
          intentionsLabel: "Intentionen:"
        },
        en: {
          langLabel: "Language",
          title: "SmartRosary Installer",
          usbTitle: `Upload firmware ${FW_VERSION} via USB`,
          otaTitle: `Upload firmware ${FW_VERSION} via Bluetooth`,
          langTitle: "Upload language via Bluetooth",
          intentsTitle: "Upload intentions via Bluetooth",
          connectUpload: "Connect & Upload",
          fwLangLabel: "Language:",
          intentionsLabel: "Intentions:"
        }
      };

      function setLanguage(lang) {
        const t = i18n[lang] || i18n.en;
        document.getElementById("title").textContent       = t.title;
        document.getElementById("usbTitle").textContent    = t.usbTitle;
        document.getElementById("otaTitle").textContent    = t.otaTitle;
        document.getElementById("langTitle").textContent   = t.langTitle;
        document.getElementById("intentsTitle").textContent= t.intentsTitle;
        document.getElementById("fwLangLabel").textContent = t.fwLangLabel;
        document.getElementById("intentionsLabel").textContent = t.intentionsLabel;
        document.querySelectorAll(".uploadBtn").forEach(btn => btn.textContent = t.connectUpload);
      }

      const uiLangSelect = document.getElementById("uiLangSelect");
      uiLangSelect.addEventListener("change", e => setLanguage(e.target.value));
      setLanguage(uiLangSelect.value);

      // ---------- 2) Screen wake-lock ----------
      let wakeLock = null;
      async function enableWakeLock() {
        try {
          if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
            wakeLock.addEventListener('release', () => console.log('Screen Wake Lock released'));
          }
        } catch (err) {
          console.warn('WakeLock error:', err.name, err.message);
        }
      }
      const noSleep = new NoSleep();
      function preventStandby() {
        enableWakeLock();
        try { noSleep.enable(); } catch {}
      }
      document.addEventListener('visibilitychange', () => {
        if (wakeLock !== null && document.visibilityState === 'visible') enableWakeLock();
      });
    </script>
    <!-- USB manifest + OTA logic -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        customElements.whenDefined("esp-web-install-button").then(() => {
          const btn     = document.querySelector("esp-web-install-button");
          const selLang = document.getElementById("language");
          const selInt  = document.getElementById("intentions");
          const origin  = window.location.origin;

          // On-disk locations (adjust to your structure)
          const firmwareParts = [
            { path: "smartrosary-web-installer/firmware/bootloader.bin", offset: 0x000000 },
            { path: "smartrosary-web-installer/firmware/partitions.bin", offset: 0x008000 },
            { path: "smartrosary-web-installer/firmware/boot_app0.bin",  offset: 0x00E000 },
            { path: "smartrosary-web-installer/firmware/firmware.bin",   offset: 0x010000 },
            { path: "smartrosary-web-installer/spiffs/wallpaper.bin",    offset: 0x323000 }
          ];

          const languages = {
            pl: { name: "Polski",  path: "smartrosary-web-installer/lang/nvs-lang-pl.bin", offset: 0x2F5000 },
            en: { name: "English", path: "smartrosary-web-installer/lang/nvs-lang-en.bin", offset: 0x2F5000 },
            de: { name: "Deutsch", path: "smartrosary-web-installer/lang/nvs-lang-de.bin", offset: 0x2F5000 }
          };

          const intentions = {
            none: null,
            rosary: {
              name: "Żywy Różaniec 2025",
              path: "smartrosary-web-installer/intentions/nvs-intentions-pmkdus-2025.bin",
              offset: 0x2F0000
            }
          };

          function buildManifest() {
            if (btn._blobUrl) URL.revokeObjectURL(btn._blobUrl);

            const rawParts = [...firmwareParts];

            // include chosen language
            const lang = languages[selLang.value];
            rawParts.splice(1, 0, { path: lang.path, offset: lang.offset });

            // include chosen intentions (optional)
            const intent = intentions[selInt.value];
            if (intent) rawParts.push({ path: intent.path, offset: intent.offset });

            // absolute URLs
            const parts = rawParts.map(p => ({
              offset: p.offset,
              path: p.path.startsWith("http") ? p.path : `${origin}/${p.path}`
            }));

            const manifest = {
              name:    `SmartRosary (${lang.name}${intent ? " / " + intent.name : ""})`,
              version: FW_VERSION,     // <-- uses single version variable
              funding_url: "",
              new_install_prompt_erase: true,
              builds: [{ chipFamily: "ESP32-C3", improv: false, parts }]
            };

            const blobUrl = URL.createObjectURL(new Blob([JSON.stringify(manifest)], { type: "application/json" }));
            btn._blobUrl = blobUrl;
            btn.manifest = blobUrl;
            console.log("Using manifest blob URL:", blobUrl);
          }

          selLang.addEventListener("change", buildManifest);
          selInt .addEventListener("change", buildManifest);
          buildManifest();
        });
      });
    </script>

    <!-- OTA uploader (firmware / lang / intentions) -->
    <script>
      // UUIDs — MUST match firmware (lowercase)
      const SERVICE_UUID       = '12345678-1234-5678-1234-56789abcdef0';
      const FIRMWARE_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef1';
      const INTENTS_CHAR_UUID  = '12345678-1234-5678-1234-56789abcde10';
      const LANG_CHAR_UUID     = '12345678-1234-5678-1234-56789abcde20';
      const STATUS_CHAR_UUID   = '12345678-1234-5678-1234-56789abcdef2';
      const INFO_CTRL_UUID     = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e10ff';  // <— ADD THIS
      

      let device, writeChar, statusChar;
      let ready = true;

      document.getElementById('uploadFirmwareBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startFirmwareOTA(ev.currentTarget); }
        catch (e) {
          if (window.GlobalUI) GlobalUI.error(e.message || 'Firmware OTA failed.');
          alert(e.message || 'Firmware OTA failed.');
        }
      });
      document.getElementById('uploadIntentionsBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startIntentionsOTA(ev.currentTarget); }
        catch (e) {
          if (window.GlobalUI) GlobalUI.error(e.message || 'Intentions OTA failed.');
          alert(e.message || 'Intentions OTA failed.');
        }
      });
      document.getElementById('uploadLanguageBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startLanguageOTA(ev.currentTarget); }
        catch (e) {
          if (window.GlobalUI) GlobalUI.error(e.message || 'Language OTA failed.');
          alert(e.message || 'Language OTA failed.');
        }
      });

      async function helloAndAwaitConsent(svc) {
        // Get control + status characteristics
        const ctrlChar  = await svc.getCharacteristic(INFO_CTRL_UUID);
        const statChar  = await svc.getCharacteristic(STATUS_CHAR_UUID);

        // Start notifications (we’ll also keep this statusChar as the global one)
        await statChar.startNotifications();

        // Wait for 0xA1 (allow) or 0xA0 (deny)
        const allowed = await new Promise(async (resolve) => {
          const onStatus = (ev) => {
            const v = new Uint8Array(ev.target.value.buffer)[0];
            if (v === 0xA1 || v === 0xA0) {
              statChar.removeEventListener('characteristicvaluechanged', onStatus);
              resolve(v === 0xA1);
            }
          };
          statChar.addEventListener('characteristicvaluechanged', onStatus);

          // Send HELLO_WEB (0x41) to pop consent on the device
          await ctrlChar.writeValue(Uint8Array.of(0x41));

          // Hard timeout to avoid hanging forever
          setTimeout(() => {
            try { statChar.removeEventListener('characteristicvaluechanged', onStatus); } catch {}
            resolve(false);
          }, 25000);
        });

        return allowed;
      }

      async function waitReady(){ while(!ready) await new Promise(r=>setTimeout(r,50)); ready=false; }

      // More robust BLE discovery: prefer service filter, fallback to acceptAllDevices
      async function connectBLE(svcUuid, charUuid){
        if (window.GlobalUI) GlobalUI.setStatus('Connecting…');
        // 1) Pick device (prefer service filter; fallback acceptAllDevices)
        try {
          device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [svcUuid] }],
            optionalServices: [svcUuid, SERVICE_UUID] // ensure our main service is always discoverable
          });
        } catch (e) {
          device = await navigator.bluetooth.requestDevice({
            acceptAllDevices: true,
            optionalServices: [svcUuid, SERVICE_UUID]
          });
          if (!device.name || !device.name.toLowerCase().startsWith('rosary')) {
            throw new Error('Picked device is not a rosary (name check failed).');
          }
        }

        // 2) Connect
        const gatt = await device.gatt.connect();

        // 3) Always get the main OTA service (it contains STATUS + INFO_CTRL)
        const svc = await gatt.getPrimaryService(SERVICE_UUID);

        // 4) Ask for consent (HELLO_WEB -> LVGL “Allow Web” modal on device)
        const consent = await helloAndAwaitConsent(svc);
        if (!consent) {
          try {
            // optional: tell device we’re backing out
            const ctrl = await svc.getCharacteristic(INFO_CTRL_UUID);
            await ctrl.writeValue(Uint8Array.of(0x42)); // CANCEL_WEB
          } catch {}
          throw new Error('Device denied consent or timed out. Please tap "Allow" on the device and try again.');
        }

        // 5) Now it’s safe to use your target write characteristic
        //    (firmware / language / intentions are separate chars under the same service)
        writeChar  = await svc.getCharacteristic(charUuid);

        // 6) Keep a global statusChar for “ready/ACK” pacing (also used above in consent)
        try {
          statusChar = await svc.getCharacteristic(STATUS_CHAR_UUID);
          statusChar.addEventListener('characteristicvaluechanged', () => { ready = true; });
          // It’s already started in helloAndAwaitConsent, but starting again is harmless
          await statusChar.startNotifications();
        } catch {
          // optional
        }
        if (window.GlobalUI) GlobalUI.setStatus('Connected. Preparing transfer…');
      }

      function setProgress(sent,total){
        if (window.GlobalUI) GlobalUI.updateProgress(sent,total);
      }

      async function startFirmwareOTA(btn){
        const resp = await fetch('firmware/firmware.bin');
        if(!resp.ok){
          if (window.GlobalUI) GlobalUI.error('Firmware package not found.');
          alert('firmware.bin not found');
          return;
        }
        const data = new Uint8Array(await resp.arrayBuffer());

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,FIRMWARE_CHAR_UUID);
        if (window.GlobalUI) GlobalUI.showProgress('Firmware OTA');

        // 4-byte size header (little-endian)
        const sizeBuf = new ArrayBuffer(4);
        new DataView(sizeBuf).setUint32(0,data.length,true);
        await writeChar.writeValue(sizeBuf);
        await waitReady();

        // chunks (MTU 517 -> safe payload 512; minus 4 for CRC)
        let offset=0, chunkSize=512-4;
        while(offset<data.length){
          const len=Math.min(chunkSize,data.length-offset);
          const chunk=data.slice(offset,offset+len);
          const crc=crc32(chunk);
          const packet=new Uint8Array(len+4);
          packet.set(chunk);
          new DataView(packet.buffer).setUint32(len,crc,true);
          await writeChar.writeValue(packet);
          await waitReady();
          offset+=len; setProgress(offset,data.length);
        }
        if (window.GlobalUI) GlobalUI.announce('Firmware OTA complete.');
      }

      async function startIntentionsOTA(btn){
        const path=document.getElementById('intentionsFileSelect').value;
        const resp=await fetch(path);
        if(!resp.ok){
          if (window.GlobalUI) GlobalUI.error('Intentions file not found.');
          alert('Intentions file not found');
          return;
        }
        const data=new Uint8Array(await resp.arrayBuffer());
        const filename = path.split('/').pop();

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,INTENTS_CHAR_UUID);
        if (window.GlobalUI) GlobalUI.showProgress('Intentions OTA');

        await sendNVS(data,filename);
        if (window.GlobalUI) GlobalUI.announce('Intentions OTA complete.');
      }

      async function startLanguageOTA(btn){
        const path=document.getElementById('languageFileSelect').value;
        const resp=await fetch(path);
        if(!resp.ok){
          if (window.GlobalUI) GlobalUI.error('Language file not found.');
          alert('Language file not found');
          return;
        }
        const data=new Uint8Array(await resp.arrayBuffer());
        const filename = path.split('/').pop();

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,LANG_CHAR_UUID);
        if (window.GlobalUI) GlobalUI.showProgress('Language OTA');

        await sendNVS(data,filename);
        if (window.GlobalUI) GlobalUI.announce('Language OTA complete.');
      }

      function crc32(buf) { let crc=0xFFFFFFFF; for(let b of buf){crc^=b; for(let i=0;i<8;i++) crc=(crc>>>1)^(0xEDB88320&-(crc&1));} return (crc^0xFFFFFFFF)>>>0; }

      async function sendNVS(data,filename){
        // filename header
        const name=new TextEncoder().encode(filename);
        await writeChar.writeValue(name);
        await waitReady();

        let offset=0, chunkSize=320; // a bit smaller than firmware chunks
        while(offset<data.length){
          const len=Math.min(chunkSize,data.length-offset);
          const chunk=data.slice(offset,offset+len);
          const crc=crc32(chunk);
          const packet=new Uint8Array(len+4);
          packet.set(chunk);
          new DataView(packet.buffer).setUint32(len,crc,true);
          await writeChar.writeValue(packet);
          await waitReady();
          offset+=len; setProgress(offset,data.length);
        }
      }
    </script>
  </body>
</html>
