<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>SmartRosary Installer</title>
    <meta name="description" content="Easily install SmartRosary firmware on the web." />
    <meta name="viewport" content="width=device-width" />
    <meta name="color-scheme" content="dark light" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
      :root {
        /* Landing/dashboard palette */
        --bg: linear-gradient(180deg, #0f5aa0 0%, #0b4f8f 55%, #09457e 100%);
        --text: #eaf0f6;
        --muted: #95a7ba;
        --card: #101722;
        --border: #172231;
        --accent: #0974cc;
        --accent-contrast: #ffffff;
        --bar: #0b4f8f;
      }

      html { min-height: 100%; background: var(--bg); }
      body { font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, sans-serif; padding: 0; margin: 0; line-height: 1.4; background: var(--bg); color: var(--text); min-height: 100vh; min-height: 100dvh; display: flex; flex-direction: column; }
      a { color: var(--accent); }

      /* Header bar */
      .header-with-lang { position: sticky; top: 0; z-index: 1000; display:flex; align-items:center; justify-content:center; gap:12px; padding: 14px 12px; background: var(--bar); border-bottom: 1px solid #b7d6f533; }
      .header-with-lang h1 { margin:0; font-size: 20px; font-weight: 700; }
      .header-with-lang .lang { position:absolute; right:12px; display:inline-flex; align-items:center; gap:6px; color:#fff; }
      .header-with-lang select { font-size: 14px; padding: 6px 10px; background: #0f1720; color: #eaf0f6; border: 1px solid #1f2b3a; border-radius: 8px; }

      /* Layout */
      .content { max-width: 720px; margin: 0 auto; padding: 12px; flex: 1; }
      h2 { margin-top: 1.0em; text-align: center; }

      /* Cards */
      .uploadBox { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 14px; margin-top: 14px; box-shadow: 0 6px 24px rgba(0,0,0,.25); }
      .footer{text-align: center;}

      /* Controls */
      .controls-container {display: flex; justify-content: center; margin-bottom: 1rem;}
      .controls-table {border-collapse: collapse;}
      .controls-table td {border: none; padding: 0.3rem 0.5rem; vertical-align: middle;}
      label { display: inline-block; width: 160px; }
      .content select { padding: 8px 10px; background:#101b2c; color:#eaf0f6; border:1px solid #233144; border-radius:8px; }

      /* Buttons */
      .uploadBtn { cursor: pointer; font-size: 14px; font-weight: 600; padding: 10px 16px; color: var(--accent-contrast); background-color: var(--accent); border: none; border-radius: 10px; transition: transform .05s ease; }
      .uploadBtn:active { transform: scale(0.98); }

      /* Movable progress container */
      #ProgressContainer { display: none; padding: 12px 12px 16px; margin-top: 10px; margin-bottom: 8px; border-radius: 10px; background: #0d131c; border: 1px solid var(--border); color: var(--text); }
      #progressTitle { font-size: 14px; font-weight: 600; margin-bottom: 6px; text-align:center; }
      #progressRow { display:flex; flex-direction:column; align-items:center; gap:6px; }
      #progressBar { width:100%; height: 18px; border-radius: 999px; }
      #progressText { font-weight: 600; }

      /* Horizontal line under progress */
      .sep { display:none; border:0; border-top:1px solid var(--border); margin: 10px 0 16px; }

      /* Native progress color */
      progress { width: 100%; height: 12px; background: #0d131c; border: 1px solid #172231; border-radius: 999px; overflow: hidden; }
      progress::-webkit-progress-bar { background: #0d131c; }
      progress::-webkit-progress-value { background: var(--accent); }
      progress::-moz-progress-bar { background: var(--accent); }
    </style>
    <script type="module" src="https://unpkg.com/esp-web-tools@10.1.0/dist/web/install-button.js"></script>
  </head>
  <body>
    <header class="header-with-lang">
      <h1 id="title">SmartRosary Web Installer</h1>
      <div class="lang">
        <select id="uiLangSelect">
          <option value="pl" selected>Polski</option>
          <option value="de">Deutsch</option>
          <option value="en">English</option>
        </select>
      </div>
    </header>
    <div class="content">

      <!-- USB -->
      <div class="uploadBox" id="usbBox">
        <h2 id="usbTitle">Upload firmware v1.0 via USB</h2>
        <div class="controls-container">
          <table class="controls-table">
            <tr>
              <td><label for="language" id="fwLangLabel">Language (firmware data):</label></td>
              <td>
                <select id="language">
                  <option value="pl" selected>Polski</option>
                  <option value="en">English</option>
                  <option value="de">Deutsch</option>
                </select>
              </td>
            </tr>
            <tr>
              <td><label for="intentions" id="intentionsLabel">Intentions:</label></td>
              <td>
                <select id="intentions">
                  <option value="none">None</option>
                  <option value="rosary">Żywy Różaniec 2025 (PMK Düsseldorf)</option>
                </select>
              </td>
            </tr>
          </table>
        </div>
        <p align="center"><esp-web-install-button></esp-web-install-button></p>
        <div class="footer">USB Installer powered by <a href="https://esphome.github.io/esp-web-tools/">ESP Web Tools</a>.</div>
      </div>

      <!-- OTA: Firmware -->
      <div class="uploadBox" id="otaFwBox">
        <h2 id="otaTitle">Upload firmware v1.0 via OTA</h2>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadFirmwareBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- OTA: Language -->
      <div class="uploadBox" id="otaLangBox">
        <h2 id="langTitle">Upload language via OTA</h2>
        <div style="text-align: center; margin-top: 1em;">
          <select id="languageFileSelect">
            <option value="lang/nvs-lang-pl.bin" selected>Polski</option>
            <option value="lang/nvs-lang-en.bin">English</option>
            <option value="lang/nvs-lang-de.bin">Deutsch</option>
          </select>
        </div>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadLanguageBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- OTA: Intentions -->
      <div class="uploadBox" id="otaIntsBox">
        <h2 id="intentsTitle">Upload intentions via OTA</h2>
        <div style="text-align: center; margin-top: 1em;">
          <select id="intentionsFileSelect">
            <option value="intentions/nvs-intentions-pmkdus-2025.bin">Żywy Różaniec 2025 (PMK Düsseldorf)</option>
          </select>
        </div>
        <div style="text-align: center; margin-top: 1em;">
          <button id="uploadIntentionsBtn" class="uploadBtn">Connect & Upload</button>
        </div>
      </div>

      <!-- Movable Progress (will be inserted under active box only AFTER connection) -->
      <div id="ProgressContainer">
        <div id="progressTitle">Uploading…</div>
        <div id="progressRow">
          <progress id="progressBar" value="0" max="0"></progress>
          <div>
            <span id="progressText">0%</span>
            <span style="margin-left: 5px;" id="progressChunks">(0/0 Bytes)</span>
          </div>
        </div>
      </div>
      <hr id="ProgressHR" class="sep" />

      <div id="log" style="display:none;"></div>
    </div>

    <!-- Wake lock helpers -->
    <script src="https://lib.arvancloud.ir/nosleep/0.91.0/NoSleep.min.js"></script>
    <script>
      // ---------- 0) Firmware version ----------
      const FW_VERSION = "v1.0";

      // ---------- 1) UI i18n ----------
      const i18n = {
        pl: {
          langLabel: "Język",
          title: "SmartRosary Instalator",
          usbTitle: `Wgraj firmware ${FW_VERSION} przez USB`,
          otaTitle: `Wgraj firmware ${FW_VERSION} przez Bluetooth`,
          langTitle: "Wgraj język przez Bluetooth",
          intentsTitle: "Wgraj intencje przez Bluetooth",
          connectUpload: "Połącz i wgraj",
          fwLangLabel: "Język:",
          intentionsLabel: "Intencje:"
        },
        de: {
          langLabel: "Sprache",
          title: "SmartRosary Installer",
          usbTitle: `Firmware ${FW_VERSION} per USB hochladen`,
          otaTitle: `Firmware ${FW_VERSION} per Bluetooth hochladen`,
          langTitle: "Sprache per Bluetooth hochladen",
          intentsTitle: "Intentionen per Bluetooth hochladen",
          connectUpload: "Verbinden & Hochladen",
          fwLangLabel: "Sprache:",
          intentionsLabel: "Intentionen:"
        },
        en: {
          langLabel: "Language",
          title: "SmartRosary Installer",
          usbTitle: `Upload firmware ${FW_VERSION} via USB`,
          otaTitle: `Upload firmware ${FW_VERSION} via Bluetooth`,
          langTitle: "Upload language via Bluetooth",
          intentsTitle: "Upload intentions via Bluetooth",
          connectUpload: "Connect & Upload",
          fwLangLabel: "Language:",
          intentionsLabel: "Intentions:"
        }
      };

      function setLanguage(lang) {
        const t = i18n[lang] || i18n.en;
        document.getElementById("title").textContent       = t.title;
        document.getElementById("usbTitle").textContent    = t.usbTitle;
        document.getElementById("otaTitle").textContent    = t.otaTitle;
        document.getElementById("langTitle").textContent   = t.langTitle;
        document.getElementById("intentsTitle").textContent= t.intentsTitle;
        document.getElementById("fwLangLabel").textContent = t.fwLangLabel;
        document.getElementById("intentionsLabel").textContent = t.intentionsLabel;
        document.querySelectorAll(".uploadBtn").forEach(btn => btn.textContent = t.connectUpload);
      }

      const uiLangSelect = document.getElementById("uiLangSelect");
      uiLangSelect.addEventListener("change", e => setLanguage(e.target.value));
      setLanguage(uiLangSelect.value);

      // ---------- 2) Screen wake-lock ----------
      let wakeLock = null;
      async function enableWakeLock() {
        try {
          if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
            wakeLock.addEventListener('release', () => console.log('Screen Wake Lock released'));
          }
        } catch (err) {
          console.warn('WakeLock error:', err.name, err.message);
        }
      }
      const noSleep = new NoSleep();
      function preventStandby() {
        enableWakeLock();
        try { noSleep.enable(); } catch {}
      }
      document.addEventListener('visibilitychange', () => {
        if (wakeLock !== null && document.visibilityState === 'visible') enableWakeLock();
      });
    </script>

    <!-- ---------- 3) Progress helpers (safe) ---------- -->
    <script>
    (() => {
      const S = {};
      function refs() {
        if (!S.container) {
          S.container = document.getElementById('ProgressContainer');
          S.hr        = document.getElementById('ProgressHR');
          S.title     = document.getElementById('progressTitle');
          S.bar       = document.getElementById('progressBar');
          S.txt       = document.getElementById('progressText');
          S.chunks    = document.getElementById('progressChunks');
        }
        return S;
      }
      function _show(anchorBox, title) {
        const R = refs();
        if (R.title)  R.title.textContent = title || 'Uploading…';
        if (R.bar)   { R.bar.value = 0; R.bar.max = 0; }
        if (R.txt)    R.txt.textContent = '0%';
        if (R.chunks) R.chunks.textContent = '(0/0 Bytes)';
        if (R.container) R.container.style.display = 'block';
        if (R.hr)        R.hr.style.display = 'block';
        if (anchorBox && R.container) {
          anchorBox.insertAdjacentElement('afterend', R.container);
          if (R.hr) R.container.insertAdjacentElement('afterend', R.hr);
          try { window.scrollTo({ top: R.container.offsetTop - 16, behavior: 'smooth' }); } catch {}
        }
      }
      function _hide() {
        const R = refs();
        if (R.container) R.container.style.display = 'none';
        if (R.hr)        R.hr.style.display = 'none';
      }
      function _update(sent, total) {
        const R = refs();
        if (R.bar) { R.bar.max = total; R.bar.value = sent; }
        if (R.txt)    R.txt.textContent = Math.round((sent / (total || 1)) * 100) + '%';
        if (R.chunks) R.chunks.textContent = `(${sent}/${total} Bytes)`;
      }
      window.showProgressContainer = _show;
      window.hideProgressContainer = _hide;
      window.updateProgress        = _update;
    })();
    </script>

    <!-- USB manifest + OTA logic -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        customElements.whenDefined("esp-web-install-button").then(() => {
          const btn     = document.querySelector("esp-web-install-button");
          const selLang = document.getElementById("language");
          const selInt  = document.getElementById("intentions");
          const origin  = window.location.origin;

          // On-disk locations (adjust to your structure)
          const firmwareParts = [
            { path: "smartrosary-web-installer/firmware/bootloader.bin", offset: 0x000000 },
            { path: "smartrosary-web-installer/firmware/partitions.bin", offset: 0x008000 },
            { path: "smartrosary-web-installer/firmware/boot_app0.bin",  offset: 0x00E000 },
            { path: "smartrosary-web-installer/firmware/firmware.bin",   offset: 0x010000 },
            { path: "smartrosary-web-installer/spiffs/wallpaper.bin",    offset: 0x323000 }
          ];

          const languages = {
            pl: { name: "Polski",  path: "smartrosary-web-installer/lang/nvs-lang-pl.bin", offset: 0x2F5000 },
            en: { name: "English", path: "smartrosary-web-installer/lang/nvs-lang-en.bin", offset: 0x2F5000 },
            de: { name: "Deutsch", path: "smartrosary-web-installer/lang/nvs-lang-de.bin", offset: 0x2F5000 }
          };

          const intentions = {
            none: null,
            rosary: {
              name: "Żywy Różaniec 2025",
              path: "smartrosary-web-installer/intentions/nvs-intentions-pmkdus-2025.bin",
              offset: 0x2F0000
            }
          };

          function buildManifest() {
            if (btn._blobUrl) URL.revokeObjectURL(btn._blobUrl);

            const rawParts = [...firmwareParts];

            // include chosen language
            const lang = languages[selLang.value];
            rawParts.splice(1, 0, { path: lang.path, offset: lang.offset });

            // include chosen intentions (optional)
            const intent = intentions[selInt.value];
            if (intent) rawParts.push({ path: intent.path, offset: intent.offset });

            // absolute URLs
            const parts = rawParts.map(p => ({
              offset: p.offset,
              path: p.path.startsWith("http") ? p.path : `${origin}/${p.path}`
            }));

            const manifest = {
              name:    `SmartRosary (${lang.name}${intent ? " / " + intent.name : ""})`,
              version: FW_VERSION,     // <-- uses single version variable
              funding_url: "",
              new_install_prompt_erase: true,
              builds: [{ chipFamily: "ESP32-C3", improv: false, parts }]
            };

            const blobUrl = URL.createObjectURL(new Blob([JSON.stringify(manifest)], { type: "application/json" }));
            btn._blobUrl = blobUrl;
            btn.manifest = blobUrl;
            console.log("Using manifest blob URL:", blobUrl);
          }

          selLang.addEventListener("change", buildManifest);
          selInt .addEventListener("change", buildManifest);
          buildManifest();
        });
      });
    </script>

    <!-- OTA uploader (firmware / lang / intentions) -->
    <script>
      // UUIDs — MUST match firmware (lowercase)
      const SERVICE_UUID       = '12345678-1234-5678-1234-56789abcdef0';
      const FIRMWARE_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef1';
      const INTENTS_CHAR_UUID  = '12345678-1234-5678-1234-56789abcde10';
      const LANG_CHAR_UUID     = '12345678-1234-5678-1234-56789abcde20';
      const STATUS_CHAR_UUID   = '12345678-1234-5678-1234-56789abcdef2';
      const INFO_CTRL_UUID     = 'b8a7a0e2-1a5d-4c1e-9d93-2c9e2b9e10ff';  // <— ADD THIS
      

      let device, writeChar, statusChar;
      let ready = true;

      document.getElementById('uploadFirmwareBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startFirmwareOTA(ev.currentTarget); }
        catch (e) { alert(e.message || 'Firmware OTA failed.'); }
      });
      document.getElementById('uploadIntentionsBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startIntentionsOTA(ev.currentTarget); }
        catch (e) { alert(e.message || 'Intentions OTA failed.'); }
      });
      document.getElementById('uploadLanguageBtn').addEventListener('click', async (ev) => {
        preventStandby();
        try { await startLanguageOTA(ev.currentTarget); }
        catch (e) { alert(e.message || 'Language OTA failed.'); }
      });

      async function helloAndAwaitConsent(svc) {
        // Get control + status characteristics
        const ctrlChar  = await svc.getCharacteristic(INFO_CTRL_UUID);
        const statChar  = await svc.getCharacteristic(STATUS_CHAR_UUID);

        // Start notifications (we’ll also keep this statusChar as the global one)
        await statChar.startNotifications();

        // Wait for 0xA1 (allow) or 0xA0 (deny)
        const allowed = await new Promise(async (resolve) => {
          const onStatus = (ev) => {
            const v = new Uint8Array(ev.target.value.buffer)[0];
            if (v === 0xA1 || v === 0xA0) {
              statChar.removeEventListener('characteristicvaluechanged', onStatus);
              resolve(v === 0xA1);
            }
          };
          statChar.addEventListener('characteristicvaluechanged', onStatus);

          // Send HELLO_WEB (0x41) to pop consent on the device
          await ctrlChar.writeValue(Uint8Array.of(0x41));

          // Hard timeout to avoid hanging forever
          setTimeout(() => {
            try { statChar.removeEventListener('characteristicvaluechanged', onStatus); } catch {}
            resolve(false);
          }, 25000);
        });

        return allowed;
      }

      async function waitReady(){ while(!ready) await new Promise(r=>setTimeout(r,50)); ready=false; }

      // More robust BLE discovery: prefer service filter, fallback to acceptAllDevices
      async function connectBLE(svcUuid, charUuid){
        // 1) Pick device (prefer service filter; fallback acceptAllDevices)
        try {
          device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [svcUuid] }],
            optionalServices: [svcUuid, SERVICE_UUID] // ensure our main service is always discoverable
          });
        } catch (e) {
          device = await navigator.bluetooth.requestDevice({
            acceptAllDevices: true,
            optionalServices: [svcUuid, SERVICE_UUID]
          });
          if (!device.name || !device.name.toLowerCase().startsWith('rosary')) {
            throw new Error('Picked device is not a rosary (name check failed).');
          }
        }

        // 2) Connect
        const gatt = await device.gatt.connect();

        // 3) Always get the main OTA service (it contains STATUS + INFO_CTRL)
        const svc = await gatt.getPrimaryService(SERVICE_UUID);

        // 4) Ask for consent (HELLO_WEB -> LVGL “Allow Web” modal on device)
        const consent = await helloAndAwaitConsent(svc);
        if (!consent) {
          try {
            // optional: tell device we’re backing out
            const ctrl = await svc.getCharacteristic(INFO_CTRL_UUID);
            await ctrl.writeValue(Uint8Array.of(0x42)); // CANCEL_WEB
          } catch {}
          throw new Error('Device denied consent or timed out. Please tap "Allow" on the device and try again.');
        }

        // 5) Now it’s safe to use your target write characteristic
        //    (firmware / language / intentions are separate chars under the same service)
        writeChar  = await svc.getCharacteristic(charUuid);

        // 6) Keep a global statusChar for “ready/ACK” pacing (also used above in consent)
        try {
          statusChar = await svc.getCharacteristic(STATUS_CHAR_UUID);
          statusChar.addEventListener('characteristicvaluechanged', () => { ready = true; });
          // It’s already started in helloAndAwaitConsent, but starting again is harmless
          await statusChar.startNotifications();
        } catch {
          // optional
        }
      }

      function setProgress(sent,total){
        updateProgress(sent,total);
      }

      async function startFirmwareOTA(btn){
        const resp = await fetch('firmware/firmware.bin'); if(!resp.ok){ alert('firmware.bin not found'); return; }
        const data = new Uint8Array(await resp.arrayBuffer());

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,FIRMWARE_CHAR_UUID);
        const box = btn.closest('.uploadBox') || document.getElementById('otaFwBox');
        showProgressContainer(box, 'Firmware OTA');

        // 4-byte size header (little-endian)
        const sizeBuf = new ArrayBuffer(4);
        new DataView(sizeBuf).setUint32(0,data.length,true);
        await writeChar.writeValue(sizeBuf);
        await waitReady();

        // chunks (MTU 517 -> safe payload 512; minus 4 for CRC)
        let offset=0, chunkSize=512-4;
        while(offset<data.length){
          const len=Math.min(chunkSize,data.length-offset);
          const chunk=data.slice(offset,offset+len);
          const crc=crc32(chunk);
          const packet=new Uint8Array(len+4);
          packet.set(chunk);
          new DataView(packet.buffer).setUint32(len,crc,true);
          await writeChar.writeValue(packet);
          await waitReady();
          offset+=len; setProgress(offset,data.length);
        }
        hideProgressContainer();
      }

      async function startIntentionsOTA(btn){
        const path=document.getElementById('intentionsFileSelect').value;
        const resp=await fetch(path); if(!resp.ok){ alert('Intentions file not found'); return; }
        const data=new Uint8Array(await resp.arrayBuffer());
        const filename = path.split('/').pop();

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,INTENTS_CHAR_UUID);
        const box = btn.closest('.uploadBox') || document.getElementById('otaIntsBox');
        showProgressContainer(box, 'Intentions OTA');

        await sendNVS(data,filename);
        hideProgressContainer();
      }

      async function startLanguageOTA(btn){
        const path=document.getElementById('languageFileSelect').value;
        const resp=await fetch(path); if(!resp.ok){ alert('Language file not found'); return; }
        const data=new Uint8Array(await resp.arrayBuffer());
        const filename = path.split('/').pop();

        // Connect first, then show progress
        await connectBLE(SERVICE_UUID,LANG_CHAR_UUID);
        const box = btn.closest('.uploadBox') || document.getElementById('otaLangBox');
        showProgressContainer(box, 'Language OTA');

        await sendNVS(data,filename);
        hideProgressContainer();
      }

      function crc32(buf) { let crc=0xFFFFFFFF; for(let b of buf){crc^=b; for(let i=0;i<8;i++) crc=(crc>>>1)^(0xEDB88320&-(crc&1));} return (crc^0xFFFFFFFF)>>>0; }

      async function sendNVS(data,filename){
        // filename header
        const name=new TextEncoder().encode(filename);
        await writeChar.writeValue(name);
        await waitReady();

        let offset=0, chunkSize=320; // a bit smaller than firmware chunks
        while(offset<data.length){
          const len=Math.min(chunkSize,data.length-offset);
          const chunk=data.slice(offset,offset+len);
          const crc=crc32(chunk);
          const packet=new Uint8Array(len+4);
          packet.set(chunk);
          new DataView(packet.buffer).setUint32(len,crc,true);
          await writeChar.writeValue(packet);
          await waitReady();
          offset+=len; updateProgress(offset,data.length);
        }
      }
    </script>
  </body>
</html>
